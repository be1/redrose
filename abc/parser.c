/* A packrat parser generated by PackCC 1.5.0 */

#define _GNU_SOURCE
#include <stdio.h>
#ifdef _MSC_VER
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef _MSC_VER
#if defined __GNUC__ && defined _WIN32 /* MinGW */
#ifndef PCC_USE_SYSTEM_STRNLEN
#define strnlen(str, maxlen) pcc_strnlen(str, maxlen)
static size_t pcc_strnlen(const char *str, size_t maxlen) {
    size_t i;
    for (i = 0; i < maxlen && str[i]; i++);
    return i;
}
#endif /* !PCC_USE_SYSTEM_STRNLEN */
#endif /* defined __GNUC__ && defined _WIN32 */
#endif /* !_MSC_VER */

#define PCC_DBG_EVALUATE 0
#define PCC_DBG_MATCH    1
#define PCC_DBG_NOMATCH  2

#include "parser.h"

#include "abc.h"


#define PCC_GETCHAR(auxil) get_char(auxil)
static int get_char(struct abc* auxil) {
        if (auxil->error)
                return -1;

        if (auxil->buffer->count == auxil->buffer->index)
                return -1;

        return auxil->buffer->buf[auxil->buffer->index++];
}

#define PCC_ERROR(auxil) print_error(auxil)
static void print_error(struct abc* auxil) {
        int line = 1;

        int l = 0;
        for (int i = 0; i < auxil->buffer->index; i++)
                if (auxil->buffer->buf[i] == '\n') {
                        line++;
                        l = i + 1;
                }

        auxil->error = 1;
        auxil->error_line = line;
        auxil->error_char = auxil->buffer->index - l;
}
#ifndef PCC_BUFFERSIZE
#define PCC_BUFFERSIZE 256
#endif /* !PCC_BUFFERSIZE */

#ifndef PCC_ARRAYSIZE
#define PCC_ARRAYSIZE 2
#endif /* !PCC_ARRAYSIZE */

#define VOID_VALUE (~(size_t)0)

typedef enum pcc_bool_tag {
    PCC_FALSE = 0,
    PCC_TRUE
} pcc_bool_t;

typedef struct pcc_char_array_tag {
    char *buf;
    size_t max;
    size_t len;
} pcc_char_array_t;

typedef struct pcc_range_tag {
    size_t start;
    size_t end;
} pcc_range_t;

typedef int pcc_value_t;

typedef struct abc *pcc_auxil_t;

typedef struct pcc_value_table_tag {
    pcc_value_t *buf;
    size_t max;
    size_t len;
} pcc_value_table_t;

typedef struct pcc_value_refer_table_tag {
    pcc_value_t **buf;
    size_t max;
    size_t len;
} pcc_value_refer_table_t;

typedef struct pcc_capture_tag {
    pcc_range_t range;
    char *string; /* mutable */
} pcc_capture_t;

typedef struct pcc_capture_table_tag {
    pcc_capture_t *buf;
    size_t max;
    size_t len;
} pcc_capture_table_t;

typedef struct pcc_capture_const_table_tag {
    const pcc_capture_t **buf;
    size_t max;
    size_t len;
} pcc_capture_const_table_t;

typedef struct pcc_thunk_tag pcc_thunk_t;
typedef struct pcc_thunk_array_tag pcc_thunk_array_t;

typedef void (*pcc_action_t)(pcc_context_t *, pcc_thunk_t *, pcc_value_t *);

typedef enum pcc_thunk_type_tag {
    PCC_THUNK_LEAF,
    PCC_THUNK_NODE
} pcc_thunk_type_t;

typedef struct pcc_thunk_leaf_tag {
    pcc_value_refer_table_t values;
    pcc_capture_const_table_t capts;
    pcc_capture_t capt0;
    pcc_action_t action;
} pcc_thunk_leaf_t;

typedef struct pcc_thunk_node_tag {
    const pcc_thunk_array_t *thunks; /* just a reference */
    pcc_value_t *value; /* just a reference */
} pcc_thunk_node_t;

typedef union pcc_thunk_data_tag {
    pcc_thunk_leaf_t leaf;
    pcc_thunk_node_t node;
} pcc_thunk_data_t;

struct pcc_thunk_tag {
    pcc_thunk_type_t type;
    pcc_thunk_data_t data;
};

struct pcc_thunk_array_tag {
    pcc_thunk_t **buf;
    size_t max;
    size_t len;
};

typedef struct pcc_thunk_chunk_tag {
    pcc_value_table_t values;
    pcc_capture_table_t capts;
    pcc_thunk_array_t thunks;
    size_t pos; /* the starting position in the character buffer */
} pcc_thunk_chunk_t;

typedef struct pcc_lr_entry_tag pcc_lr_entry_t;

typedef enum pcc_lr_answer_type_tag {
    PCC_LR_ANSWER_LR,
    PCC_LR_ANSWER_CHUNK
} pcc_lr_answer_type_t;

typedef union pcc_lr_answer_data_tag {
    pcc_lr_entry_t *lr;
    pcc_thunk_chunk_t *chunk;
} pcc_lr_answer_data_t;

typedef struct pcc_lr_answer_tag pcc_lr_answer_t;

struct pcc_lr_answer_tag {
    pcc_lr_answer_type_t type;
    pcc_lr_answer_data_t data;
    size_t pos; /* the absolute position in the input */
    pcc_lr_answer_t *hold;
};

typedef pcc_thunk_chunk_t *(*pcc_rule_t)(pcc_context_t *);

typedef struct pcc_rule_set_tag {
    pcc_rule_t *buf;
    size_t max;
    size_t len;
} pcc_rule_set_t;

typedef struct pcc_lr_head_tag pcc_lr_head_t;

struct pcc_lr_head_tag {
    pcc_rule_t rule;
    pcc_rule_set_t invol;
    pcc_rule_set_t eval;
    pcc_lr_head_t *hold;
};

typedef struct pcc_lr_memo_tag {
    pcc_rule_t rule;
    pcc_lr_answer_t *answer;
} pcc_lr_memo_t;

typedef struct pcc_lr_memo_map_tag {
    pcc_lr_memo_t *buf;
    size_t max;
    size_t len;
} pcc_lr_memo_map_t;

typedef struct pcc_lr_table_entry_tag {
    pcc_lr_head_t *head; /* just a reference */
    pcc_lr_memo_map_t memos;
    pcc_lr_answer_t *hold_a;
    pcc_lr_head_t *hold_h;
} pcc_lr_table_entry_t;

typedef struct pcc_lr_table_tag {
    pcc_lr_table_entry_t **buf;
    size_t max;
    size_t len;
} pcc_lr_table_t;

struct pcc_lr_entry_tag {
    pcc_rule_t rule;
    pcc_thunk_chunk_t *seed; /* just a reference */
    pcc_lr_head_t *head; /* just a reference */
};

typedef struct pcc_lr_stack_tag {
    pcc_lr_entry_t **buf;
    size_t max;
    size_t len;
} pcc_lr_stack_t;

struct pcc_context_tag {
    size_t pos; /* the position in the input of the first character currently buffered */
    size_t cur; /* the current parsing position in the character buffer */
    size_t level;
    pcc_char_array_t buffer;
    pcc_lr_table_t lrtable;
    pcc_lr_stack_t lrstack;
    pcc_auxil_t auxil;
};

#ifndef PCC_ERROR
#define PCC_ERROR(auxil) pcc_error()
static void pcc_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PCC_ERROR */

#ifndef PCC_GETCHAR
#define PCC_GETCHAR(auxil) getchar()
#endif /* !PCC_GETCHAR */

#ifndef PCC_MALLOC
#define PCC_MALLOC(auxil, size) pcc_malloc_e(size)
static void *pcc_malloc_e(size_t size) {
    void *const p = malloc(size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_MALLOC */

#ifndef PCC_REALLOC
#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)
static void *pcc_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_REALLOC */

#ifndef PCC_FREE
#define PCC_FREE(auxil, ptr) free(ptr)
#endif /* !PCC_FREE */

#ifndef PCC_DEBUG
#define PCC_DEBUG(event, rule, level, pos, buffer, length) ((void)0)
#endif /* !PCC_DEBUG */

static char *pcc_strndup_e(pcc_auxil_t auxil, const char *str, size_t len) {
    const size_t m = strnlen(str, len);
    char *const s = (char *)PCC_MALLOC(auxil, m + 1);
    memcpy(s, str, m);
    s[m] = '\0';
    return s;
}

static void pcc_char_array__init(pcc_auxil_t auxil, pcc_char_array_t *array, size_t max) {
    array->len = 0;
    array->max = max;
    array->buf = (char *)PCC_MALLOC(auxil, array->max);
}

static void pcc_char_array__add(pcc_auxil_t auxil, pcc_char_array_t *array, char ch) {
    if (array->max <= array->len) {
        const size_t n = array->len + 1;
        size_t m = array->max;
        if (m == 0) m = 1;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        array->buf = (char *)PCC_REALLOC(auxil, array->buf, m);
        array->max = m;
    }
    array->buf[array->len++] = ch;
}

static void pcc_char_array__term(pcc_auxil_t auxil, pcc_char_array_t *array) {
    PCC_FREE(auxil, array->buf);
}

static void pcc_value_table__init(pcc_auxil_t auxil, pcc_value_table_t *table, size_t max) {
    table->len = 0;
    table->max = max;
    table->buf = (pcc_value_t *)PCC_MALLOC(auxil, sizeof(pcc_value_t) * table->max);
}

static void pcc_value_table__resize(pcc_auxil_t auxil, pcc_value_table_t *table, size_t len) {
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = 1;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t) * m);
        table->max = m;
    }
    table->len = len;
}

static void pcc_value_table__term(pcc_auxil_t auxil, pcc_value_table_t *table) {
    PCC_FREE(auxil, table->buf);
}

static void pcc_value_refer_table__init(pcc_auxil_t auxil, pcc_value_refer_table_t *table, size_t max) {
    table->len = 0;
    table->max = max;
    table->buf = (pcc_value_t **)PCC_MALLOC(auxil, sizeof(pcc_value_t *) * table->max);
}

static void pcc_value_refer_table__resize(pcc_auxil_t auxil, pcc_value_refer_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = 1;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t **)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_value_refer_table__term(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {
    PCC_FREE(auxil, table->buf);
}

static void pcc_capture_table__init(pcc_auxil_t auxil, pcc_capture_table_t *table, size_t max) {
    table->len = 0;
    table->max = max;
    table->buf = (pcc_capture_t *)PCC_MALLOC(auxil, sizeof(pcc_capture_t) * table->max);
}

static void pcc_capture_table__resize(pcc_auxil_t auxil, pcc_capture_table_t *table, size_t len) {
    size_t i;
    for (i = len; i < table->len; i++) PCC_FREE(auxil, table->buf[i].string);
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = 1;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_capture_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_capture_t) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) {
        table->buf[i].range.start = 0;
        table->buf[i].range.end = 0;
        table->buf[i].string = NULL;
    }
    table->len = len;
}

static void pcc_capture_table__term(pcc_auxil_t auxil, pcc_capture_table_t *table) {
    while (table->len > 0) {
        table->len--;
        PCC_FREE(auxil, table->buf[table->len].string);
    }
    PCC_FREE(auxil, table->buf);
}

static void pcc_capture_const_table__init(pcc_auxil_t auxil, pcc_capture_const_table_t *table, size_t max) {
    table->len = 0;
    table->max = max;
    table->buf = (const pcc_capture_t **)PCC_MALLOC(auxil, sizeof(const pcc_capture_t *) * table->max);
}

static void pcc_capture_const_table__resize(pcc_auxil_t auxil, pcc_capture_const_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = 1;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (const pcc_capture_t **)PCC_REALLOC(auxil, (pcc_capture_t **)table->buf, sizeof(const pcc_capture_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_capture_const_table__term(pcc_auxil_t auxil, pcc_capture_const_table_t *table) {
    PCC_FREE(auxil, table->buf);
}

static pcc_thunk_t *pcc_thunk__create_leaf(pcc_auxil_t auxil, pcc_action_t action, size_t valuec, size_t captc) {
    pcc_thunk_t *const thunk = (pcc_thunk_t *)PCC_MALLOC(auxil, sizeof(pcc_thunk_t));
    thunk->type = PCC_THUNK_LEAF;
    pcc_value_refer_table__init(auxil, &thunk->data.leaf.values, valuec);
    pcc_value_refer_table__resize(auxil, &thunk->data.leaf.values, valuec);
    pcc_capture_const_table__init(auxil, &thunk->data.leaf.capts, captc);
    pcc_capture_const_table__resize(auxil, &thunk->data.leaf.capts, captc);
    thunk->data.leaf.capt0.range.start = 0;
    thunk->data.leaf.capt0.range.end = 0;
    thunk->data.leaf.capt0.string = NULL;
    thunk->data.leaf.action = action;
    return thunk;
}

static pcc_thunk_t *pcc_thunk__create_node(pcc_auxil_t auxil, const pcc_thunk_array_t *thunks, pcc_value_t *value) {
    pcc_thunk_t *const thunk = (pcc_thunk_t *)PCC_MALLOC(auxil, sizeof(pcc_thunk_t));
    thunk->type = PCC_THUNK_NODE;
    thunk->data.node.thunks = thunks;
    thunk->data.node.value = value;
    return thunk;
}

static void pcc_thunk__destroy(pcc_auxil_t auxil, pcc_thunk_t *thunk) {
    if (thunk == NULL) return;
    switch (thunk->type) {
    case PCC_THUNK_LEAF:
        PCC_FREE(auxil, thunk->data.leaf.capt0.string);
        pcc_capture_const_table__term(auxil, &thunk->data.leaf.capts);
        pcc_value_refer_table__term(auxil, &thunk->data.leaf.values);
        break;
    case PCC_THUNK_NODE:
        break;
    default: /* unknown */
        break;
    }
    PCC_FREE(auxil, thunk);
}

static void pcc_thunk_array__init(pcc_auxil_t auxil, pcc_thunk_array_t *array, size_t max) {
    array->len = 0;
    array->max = max;
    array->buf = (pcc_thunk_t **)PCC_MALLOC(auxil, sizeof(pcc_thunk_t *) * array->max);
}

static void pcc_thunk_array__add(pcc_auxil_t auxil, pcc_thunk_array_t *array, pcc_thunk_t *thunk) {
    if (array->max <= array->len) {
        const size_t n = array->len + 1;
        size_t m = array->max;
        if (m == 0) m = 1;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        array->buf = (pcc_thunk_t **)PCC_REALLOC(auxil, array->buf, sizeof(pcc_thunk_t *) * m);
        array->max = m;
    }
    array->buf[array->len++] = thunk;
}

static void pcc_thunk_array__revert(pcc_auxil_t auxil, pcc_thunk_array_t *array, size_t len) {
    while (array->len > len) {
        array->len--;
        pcc_thunk__destroy(auxil, array->buf[array->len]);
    }
}

static void pcc_thunk_array__term(pcc_auxil_t auxil, pcc_thunk_array_t *array) {
    while (array->len > 0) {
        array->len--;
        pcc_thunk__destroy(auxil, array->buf[array->len]);
    }
    PCC_FREE(auxil, array->buf);
}

static pcc_thunk_chunk_t *pcc_thunk_chunk__create(pcc_auxil_t auxil) {
    pcc_thunk_chunk_t *const chunk = (pcc_thunk_chunk_t *)PCC_MALLOC(auxil, sizeof(pcc_thunk_chunk_t));
    pcc_value_table__init(auxil, &chunk->values, PCC_ARRAYSIZE);
    pcc_capture_table__init(auxil, &chunk->capts, PCC_ARRAYSIZE);
    pcc_thunk_array__init(auxil, &chunk->thunks, PCC_ARRAYSIZE);
    chunk->pos = 0;
    return chunk;
}

static void pcc_thunk_chunk__destroy(pcc_auxil_t auxil, pcc_thunk_chunk_t *chunk) {
    if (chunk == NULL) return;
    pcc_thunk_array__term(auxil, &chunk->thunks);
    pcc_capture_table__term(auxil, &chunk->capts);
    pcc_value_table__term(auxil, &chunk->values);
    PCC_FREE(auxil, chunk);
}

static void pcc_rule_set__init(pcc_auxil_t auxil, pcc_rule_set_t *set, size_t max) {
    set->len = 0;
    set->max = max;
    set->buf = (pcc_rule_t *)PCC_MALLOC(auxil, sizeof(pcc_rule_t) * set->max);
}

static size_t pcc_rule_set__index(pcc_auxil_t auxil, const pcc_rule_set_t *set, pcc_rule_t rule) {
    size_t i;
    for (i = 0; i < set->len; i++) {
        if (set->buf[i] == rule) return i;
    }
    return VOID_VALUE;
}

static pcc_bool_t pcc_rule_set__add(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {
    const size_t i = pcc_rule_set__index(auxil, set, rule);
    if (i != VOID_VALUE) return PCC_FALSE;
    if (set->max <= set->len) {
        const size_t n = set->len + 1;
        size_t m = set->max;
        if (m == 0) m = 1;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        set->buf = (pcc_rule_t *)PCC_REALLOC(auxil, set->buf, sizeof(pcc_rule_t) * m);
        set->max = m;
    }
    set->buf[set->len++] = rule;
    return PCC_TRUE;
}

static pcc_bool_t pcc_rule_set__remove(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {
    const size_t i = pcc_rule_set__index(auxil, set, rule);
    if (i == VOID_VALUE) return PCC_FALSE;
    memmove(set->buf + i, set->buf + (i + 1), sizeof(pcc_rule_t) * (set->len - (i + 1)));
    return PCC_TRUE;
}

static void pcc_rule_set__clear(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    set->len = 0;
}

static void pcc_rule_set__copy(pcc_auxil_t auxil, pcc_rule_set_t *set, const pcc_rule_set_t *src) {
    size_t i;
    pcc_rule_set__clear(auxil, set);
    for (i = 0; i < src->len; i++) {
        pcc_rule_set__add(auxil, set, src->buf[i]);
    }
}

static void pcc_rule_set__term(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    PCC_FREE(auxil, set->buf);
}

static pcc_lr_head_t *pcc_lr_head__create(pcc_auxil_t auxil, pcc_rule_t rule) {
    pcc_lr_head_t *const head = (pcc_lr_head_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_head_t));
    head->rule = rule;
    pcc_rule_set__init(auxil, &head->invol, PCC_ARRAYSIZE);
    pcc_rule_set__init(auxil, &head->eval, PCC_ARRAYSIZE);
    head->hold = NULL;
    return head;
}

static void pcc_lr_head__destroy(pcc_auxil_t auxil, pcc_lr_head_t *head) {
    if (head == NULL) return;
    pcc_lr_head__destroy(auxil, head->hold);
    pcc_rule_set__term(auxil, &head->eval);
    pcc_rule_set__term(auxil, &head->invol);
    PCC_FREE(auxil, head);
}

static void pcc_lr_entry__destroy(pcc_auxil_t auxil, pcc_lr_entry_t *lr);

static pcc_lr_answer_t *pcc_lr_answer__create(pcc_auxil_t auxil, pcc_lr_answer_type_t type, size_t pos) {
    pcc_lr_answer_t *answer = (pcc_lr_answer_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_answer_t));
    answer->type = type;
    answer->pos = pos;
    answer->hold = NULL;
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        answer->data.lr = NULL;
        break;
    case PCC_LR_ANSWER_CHUNK:
        answer->data.chunk = NULL;
        break;
    default: /* unknown */
        PCC_FREE(auxil, answer);
        answer = NULL;
    }
    return answer;
}

static void pcc_lr_answer__set_chunk(pcc_auxil_t auxil, pcc_lr_answer_t *answer, pcc_thunk_chunk_t *chunk) {
    pcc_lr_answer_t *const a = pcc_lr_answer__create(auxil, answer->type, answer->pos);
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        a->data.lr = answer->data.lr;
        break;
    case PCC_LR_ANSWER_CHUNK:
        a->data.chunk = answer->data.chunk;
        break;
    default: /* unknown */
        break;
    }
    a->hold = answer->hold;
    answer->hold = a;
    answer->type = PCC_LR_ANSWER_CHUNK;
    answer->data.chunk = chunk;
}

static void pcc_lr_answer__destroy(pcc_auxil_t auxil, pcc_lr_answer_t *answer) {
    if (answer == NULL) return;
    pcc_lr_answer__destroy(auxil, answer->hold);
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        pcc_lr_entry__destroy(auxil, answer->data.lr);
        break;
    case PCC_LR_ANSWER_CHUNK:
        pcc_thunk_chunk__destroy(auxil, answer->data.chunk);
        break;
    default: /* unknown */
        break;
    }
    PCC_FREE(auxil, answer);
}

static void pcc_lr_memo_map__init(pcc_auxil_t auxil, pcc_lr_memo_map_t *map, size_t max) {
    map->len = 0;
    map->max = max;
    map->buf = (pcc_lr_memo_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_memo_t) * map->max);
}

static size_t pcc_lr_memo_map__index(pcc_auxil_t auxil, pcc_lr_memo_map_t *map, pcc_rule_t rule) {
    size_t i;
    for (i = 0; i < map->len; i++) {
        if (map->buf[i].rule == rule) return i;
    }
    return VOID_VALUE;
}

static void pcc_lr_memo_map__put(pcc_auxil_t auxil, pcc_lr_memo_map_t *map, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    const size_t i = pcc_lr_memo_map__index(auxil, map, rule);
    if (i != VOID_VALUE) {
        pcc_lr_answer__destroy(auxil, map->buf[i].answer);
        map->buf[i].answer = answer;
    }
    else {
        if (map->max <= map->len) {
            const size_t n = map->len + 1;
            size_t m = map->max;
            if (m == 0) m = 1;
            while (m < n && m != 0) m <<= 1;
            if (m == 0) m = n;
            map->buf = (pcc_lr_memo_t *)PCC_REALLOC(auxil, map->buf, sizeof(pcc_lr_memo_t) * m);
            map->max = m;
        }
        map->buf[map->len].rule = rule;
        map->buf[map->len].answer = answer;
        map->len++;
    }
}

static pcc_lr_answer_t *pcc_lr_memo_map__get(pcc_auxil_t auxil, pcc_lr_memo_map_t *map, pcc_rule_t rule) {
    const size_t i = pcc_lr_memo_map__index(auxil, map, rule);
    return (i != VOID_VALUE) ? map->buf[i].answer : NULL;
}

static void pcc_lr_memo_map__term(pcc_auxil_t auxil, pcc_lr_memo_map_t *map) {
    while (map->len > 0) {
        map->len--;
        pcc_lr_answer__destroy(auxil, map->buf[map->len].answer);
    }
    PCC_FREE(auxil, map->buf);
}

static pcc_lr_table_entry_t *pcc_lr_table_entry__create(pcc_auxil_t auxil) {
    pcc_lr_table_entry_t *const entry = (pcc_lr_table_entry_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_table_entry_t));
    entry->head = NULL;
    pcc_lr_memo_map__init(auxil, &entry->memos, PCC_ARRAYSIZE);
    entry->hold_a = NULL;
    entry->hold_h = NULL;
    return entry;
}

static void pcc_lr_table_entry__destroy(pcc_auxil_t auxil, pcc_lr_table_entry_t *entry) {
    if (entry == NULL) return;
    pcc_lr_head__destroy(auxil, entry->hold_h);
    pcc_lr_answer__destroy(auxil, entry->hold_a);
    pcc_lr_memo_map__term(auxil, &entry->memos);
    PCC_FREE(auxil, entry);
}

static void pcc_lr_table__init(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t max) {
    table->len = 0;
    table->max = max;
    table->buf = (pcc_lr_table_entry_t **)PCC_MALLOC(auxil, sizeof(pcc_lr_table_entry_t *) * table->max);
}

static void pcc_lr_table__resize(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t len) {
    size_t i;
    for (i = len; i < table->len; i++) pcc_lr_table_entry__destroy(auxil, table->buf[i]);
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = 1;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_lr_table_entry_t **)PCC_REALLOC(auxil, table->buf, sizeof(pcc_lr_table_entry_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_lr_table__set_head(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t index, pcc_lr_head_t *head) {
    if (index >= table->len) pcc_lr_table__resize(auxil, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(auxil);
    table->buf[index]->head = head;
}

static void pcc_lr_table__hold_head(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t index, pcc_lr_head_t *head) {
    if (index >= table->len) pcc_lr_table__resize(auxil, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(auxil);
    head->hold = table->buf[index]->hold_h;
    table->buf[index]->hold_h = head;
}

static void pcc_lr_table__set_answer(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t index, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    if (index >= table->len) pcc_lr_table__resize(auxil, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(auxil);
    pcc_lr_memo_map__put(auxil, &table->buf[index]->memos, rule, answer);
}

static void pcc_lr_table__hold_answer(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t index, pcc_lr_answer_t *answer) {
    if (index >= table->len) pcc_lr_table__resize(auxil, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(auxil);
    answer->hold = table->buf[index]->hold_a;
    table->buf[index]->hold_a = answer;
}

static pcc_lr_head_t *pcc_lr_table__get_head(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t index) {
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return table->buf[index]->head;
}

static pcc_lr_answer_t *pcc_lr_table__get_answer(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t index, pcc_rule_t rule) {
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return pcc_lr_memo_map__get(auxil, &table->buf[index]->memos, rule);
}

static void pcc_lr_table__shift(pcc_auxil_t auxil, pcc_lr_table_t *table, size_t count) {
    size_t i;
    if (count > table->len) count = table->len;
    for (i = 0; i < count; i++) pcc_lr_table_entry__destroy(auxil, table->buf[i]);
    memmove(table->buf, table->buf + count, sizeof(pcc_lr_table_entry_t *) * (table->len - count));
    table->len -= count;
}

static void pcc_lr_table__term(pcc_auxil_t auxil, pcc_lr_table_t *table) {
    while (table->len > 0) {
        table->len--;
        pcc_lr_table_entry__destroy(auxil, table->buf[table->len]);
    }
    PCC_FREE(auxil, table->buf);
}

static pcc_lr_entry_t *pcc_lr_entry__create(pcc_auxil_t auxil, pcc_rule_t rule) {
    pcc_lr_entry_t *const lr = (pcc_lr_entry_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_entry_t));
    lr->rule = rule;
    lr->seed = NULL;
    lr->head = NULL;
    return lr;
}

static void pcc_lr_entry__destroy(pcc_auxil_t auxil, pcc_lr_entry_t *lr) {
    PCC_FREE(auxil, lr);
}

static void pcc_lr_stack__init(pcc_auxil_t auxil, pcc_lr_stack_t *stack, size_t max) {
    stack->len = 0;
    stack->max = max;
    stack->buf = (pcc_lr_entry_t **)PCC_MALLOC(auxil, sizeof(pcc_lr_entry_t *) * stack->max);
}

static void pcc_lr_stack__push(pcc_auxil_t auxil, pcc_lr_stack_t *stack, pcc_lr_entry_t *lr) {
    if (stack->max <= stack->len) {
        const size_t n = stack->len + 1;
        size_t m = stack->max;
        if (m == 0) m = 1;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        stack->buf = (pcc_lr_entry_t **)PCC_REALLOC(auxil, stack->buf, sizeof(pcc_lr_entry_t *) * m);
        stack->max = m;
    }
    stack->buf[stack->len++] = lr;
}

static pcc_lr_entry_t *pcc_lr_stack__pop(pcc_auxil_t auxil, pcc_lr_stack_t *stack) {
    return stack->buf[--stack->len];
}

static void pcc_lr_stack__term(pcc_auxil_t auxil, pcc_lr_stack_t *stack) {
    PCC_FREE(auxil, stack->buf);
}

static pcc_context_t *pcc_context__create(pcc_auxil_t auxil) {
    pcc_context_t *const ctx = (pcc_context_t *)PCC_MALLOC(auxil, sizeof(pcc_context_t));
    ctx->pos = 0;
    ctx->cur = 0;
    ctx->level = 0;
    pcc_char_array__init(auxil, &ctx->buffer, PCC_BUFFERSIZE);
    pcc_lr_table__init(auxil, &ctx->lrtable, PCC_BUFFERSIZE);
    pcc_lr_stack__init(auxil, &ctx->lrstack, PCC_ARRAYSIZE);
    ctx->auxil = auxil;
    return ctx;
}

static void pcc_context__destroy(pcc_context_t *ctx) {
    if (ctx == NULL) return;
    pcc_lr_stack__term(ctx->auxil, &ctx->lrstack);
    pcc_lr_table__term(ctx->auxil, &ctx->lrtable);
    pcc_char_array__term(ctx->auxil, &ctx->buffer);
    PCC_FREE(ctx->auxil, ctx);
}

static size_t pcc_refill_buffer(pcc_context_t *ctx, size_t num) {
    if (ctx->buffer.len >= ctx->cur + num) return ctx->buffer.len - ctx->cur;
    while (ctx->buffer.len < ctx->cur + num) {
        const int c = PCC_GETCHAR(ctx->auxil);
        if (c == EOF) break;
        pcc_char_array__add(ctx->auxil, &ctx->buffer, (char)c);
    }
    return ctx->buffer.len - ctx->cur;
}

static void pcc_commit_buffer(pcc_context_t *ctx) {
    memmove(ctx->buffer.buf, ctx->buffer.buf + ctx->cur, ctx->buffer.len - ctx->cur);
    ctx->buffer.len -= ctx->cur;
    ctx->pos += ctx->cur;
    pcc_lr_table__shift(ctx->auxil, &ctx->lrtable, ctx->cur);
    ctx->cur = 0;
}

static const char *pcc_get_capture_string(pcc_context_t *ctx, const pcc_capture_t *capt) {
    if (capt->string == NULL)
        ((pcc_capture_t *)capt)->string =
            pcc_strndup_e(ctx->auxil, ctx->buffer.buf + capt->range.start, capt->range.end - capt->range.start);
    return capt->string;
}

static size_t pcc_get_char_as_utf32(pcc_context_t *ctx, int *out) { /* with checking UTF-8 validity */
    int c, u;
    size_t n;
    if (pcc_refill_buffer(ctx, 1) < 1) return 0;
    c = (int)(unsigned char)ctx->buffer.buf[ctx->cur];
    n = (c < 0x80) ? 1 :
        ((c & 0xe0) == 0xc0) ? 2 :
        ((c & 0xf0) == 0xe0) ? 3 :
        ((c & 0xf8) == 0xf0) ? 4 : 0;
    if (n < 1) return 0;
    if (pcc_refill_buffer(ctx, n) < n) return 0;
    switch (n) {
    case 1:
        u = c;
        break;
    case 2:
        u = c & 0x1f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->cur + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x80) return 0;
        break;
    case 3:
        u = c & 0x0f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->cur + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->cur + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x800) return 0;
        break;
    case 4:
        u = c & 0x07;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->cur + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->cur + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->cur + 3];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x10000 || u > 0x10ffff) return 0;
        break;
    default:
        return 0;
    }
    if (out) *out = u;
    return n;
}

static pcc_bool_t pcc_apply_rule(pcc_context_t *ctx, pcc_rule_t rule, pcc_thunk_array_t *thunks, pcc_value_t *value) {
    static pcc_value_t null;
    pcc_thunk_chunk_t *c = NULL;
    const size_t p = ctx->pos + ctx->cur;
    pcc_bool_t b = PCC_TRUE;
    pcc_lr_answer_t *a = pcc_lr_table__get_answer(ctx->auxil, &ctx->lrtable, p, rule);
    pcc_lr_head_t *h = pcc_lr_table__get_head(ctx->auxil, &ctx->lrtable, p);
    if (h != NULL) {
        if (a == NULL && rule != h->rule && pcc_rule_set__index(ctx->auxil, &h->invol, rule) == VOID_VALUE) {
            b = PCC_FALSE;
            c = NULL;
        }
        else if (pcc_rule_set__remove(ctx->auxil, &h->eval, rule)) {
            b = PCC_FALSE;
            c = rule(ctx);
            a = pcc_lr_answer__create(ctx->auxil, PCC_LR_ANSWER_CHUNK, ctx->pos + ctx->cur);
            a->data.chunk = c;
            pcc_lr_table__hold_answer(ctx->auxil, &ctx->lrtable, p, a);
        }
    }
    if (b) {
        if (a != NULL) {
            ctx->cur = a->pos - ctx->pos;
            switch (a->type) {
            case PCC_LR_ANSWER_LR:
                if (a->data.lr->head == NULL) {
                    a->data.lr->head = pcc_lr_head__create(ctx->auxil, rule);
                    pcc_lr_table__hold_head(ctx->auxil, &ctx->lrtable, p, a->data.lr->head);
                }
                {
                    size_t i = ctx->lrstack.len;
                    while (i > 0) {
                        i--;
                        if (ctx->lrstack.buf[i]->head == a->data.lr->head) break;
                        ctx->lrstack.buf[i]->head = a->data.lr->head;
                        pcc_rule_set__add(ctx->auxil, &a->data.lr->head->invol, ctx->lrstack.buf[i]->rule);
                    }
                }
                c = a->data.lr->seed;
                break;
            case PCC_LR_ANSWER_CHUNK:
                c = a->data.chunk;
                break;
            default: /* unknown */
                break;
            }
        }
        else {
            pcc_lr_entry_t *const e = pcc_lr_entry__create(ctx->auxil, rule);
            pcc_lr_stack__push(ctx->auxil, &ctx->lrstack, e);
            a = pcc_lr_answer__create(ctx->auxil, PCC_LR_ANSWER_LR, p);
            a->data.lr = e;
            pcc_lr_table__set_answer(ctx->auxil, &ctx->lrtable, p, rule, a);
            c = rule(ctx);
            pcc_lr_stack__pop(ctx->auxil, &ctx->lrstack);
            a->pos = ctx->pos + ctx->cur;
            if (e->head == NULL) {
                pcc_lr_answer__set_chunk(ctx->auxil, a, c);
            }
            else {
                e->seed = c;
                h = a->data.lr->head;
                if (h->rule != rule) {
                    c = a->data.lr->seed;
                    a = pcc_lr_answer__create(ctx->auxil, PCC_LR_ANSWER_CHUNK, ctx->pos + ctx->cur);
                    a->data.chunk = c;
                    pcc_lr_table__hold_answer(ctx->auxil, &ctx->lrtable, p, a);
                }
                else {
                    pcc_lr_answer__set_chunk(ctx->auxil, a, a->data.lr->seed);
                    if (a->data.chunk == NULL) {
                        c = NULL;
                    }
                    else {
                        pcc_lr_table__set_head(ctx->auxil, &ctx->lrtable, p, h);
                        for (;;) {
                            ctx->cur = p - ctx->pos;
                            pcc_rule_set__copy(ctx->auxil, &h->eval, &h->invol);
                            c = rule(ctx);
                            if (c == NULL || ctx->pos + ctx->cur <= a->pos) break;
                            pcc_lr_answer__set_chunk(ctx->auxil, a, c);
                            a->pos = ctx->pos + ctx->cur;
                        }
                        pcc_thunk_chunk__destroy(ctx->auxil, c);
                        pcc_lr_table__set_head(ctx->auxil, &ctx->lrtable, p, NULL);
                        ctx->cur = a->pos - ctx->pos;
                        c = a->data.chunk;
                    }
                }
            }
        }
    }
    if (c == NULL) return PCC_FALSE;
    if (value == NULL) value = &null;
    memset(value, 0, sizeof(pcc_value_t)); /* in case */
    pcc_thunk_array__add(ctx->auxil, thunks, pcc_thunk__create_node(ctx->auxil, &c->thunks, value));
    return PCC_TRUE;
}

static void pcc_do_action(pcc_context_t *ctx, const pcc_thunk_array_t *thunks, pcc_value_t *value) {
    size_t i;
    for (i = 0; i < thunks->len; i++) {
        pcc_thunk_t *const thunk = thunks->buf[i];
        switch (thunk->type) {
        case PCC_THUNK_LEAF:
            thunk->data.leaf.action(ctx, thunk, value);
            break;
        case PCC_THUNK_NODE:
            pcc_do_action(ctx, thunk->data.node.thunks, thunk->data.node.value);
            break;
        default: /* unknown */
            break;
        }
    }
}

static void pcc_action_Xvalue_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_tune_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Kheader_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_header_append(auxil, _1, 'K');
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_header_append(auxil, _1, 'A');
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_1(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _2 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.end))
    abc_header_append(auxil, _2, 'B');
#undef _2e
#undef _2s
#undef _2
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_2(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _3 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[2])
#define _3s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[2]->range.start))
#define _3e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[2]->range.end))
    abc_header_append(auxil, _3, 'C');
#undef _3e
#undef _3s
#undef _3
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_3(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _4 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[3])
#define _4s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[3]->range.start))
#define _4e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[3]->range.end))
    abc_header_append(auxil, _4, 'D');
#undef _4e
#undef _4s
#undef _4
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_4(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _5 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[4])
#define _5s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[4]->range.start))
#define _5e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[4]->range.end))
    abc_header_append(auxil, _5, 'F');
#undef _5e
#undef _5s
#undef _5
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_5(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _6 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[5])
#define _6s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[5]->range.start))
#define _6e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[5]->range.end))
    abc_header_append(auxil, _6, 'G');
#undef _6e
#undef _6s
#undef _6
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_6(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _7 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[6])
#define _7s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[6]->range.start))
#define _7e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[6]->range.end))
    abc_header_append(auxil, _7, 'H');
#undef _7e
#undef _7s
#undef _7
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_7(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _8 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[7])
#define _8s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[7]->range.start))
#define _8e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[7]->range.end))
    abc_header_append(auxil, _8, 'I');
#undef _8e
#undef _8s
#undef _8
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_8(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _9 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[8])
#define _9s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[8]->range.start))
#define _9e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[8]->range.end))
    abc_header_append(auxil, _9, 'L');
#undef _9e
#undef _9s
#undef _9
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_9(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _10 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[9])
#define _10s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[9]->range.start))
#define _10e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[9]->range.end))
    abc_header_append(auxil, _10, 'M');
#undef _10e
#undef _10s
#undef _10
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_10(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _11 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[10])
#define _11s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[10]->range.start))
#define _11e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[10]->range.end))
    abc_header_append(auxil, _11, 'N');
#undef _11e
#undef _11s
#undef _11
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_11(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _12 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[11])
#define _12s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[11]->range.start))
#define _12e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[11]->range.end))
    abc_header_append(auxil, _12, 'O');
#undef _12e
#undef _12s
#undef _12
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_12(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _13 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[12])
#define _13s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[12]->range.start))
#define _13e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[12]->range.end))
    abc_header_append(auxil, _13, 'P');
#undef _13e
#undef _13s
#undef _13
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_13(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _14 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[13])
#define _14s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[13]->range.start))
#define _14e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[13]->range.end))
    abc_header_append(auxil, _14, 'Q');
#undef _14e
#undef _14s
#undef _14
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_14(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _15 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[14])
#define _15s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[14]->range.start))
#define _15e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[14]->range.end))
    abc_header_append(auxil, _15, 'R');
#undef _15e
#undef _15s
#undef _15
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_15(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _16 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[15])
#define _16s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[15]->range.start))
#define _16e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[15]->range.end))
    abc_header_append(auxil, _16, 'S');
#undef _16e
#undef _16s
#undef _16
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_16(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _17 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[16])
#define _17s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[16]->range.start))
#define _17e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[16]->range.end))
    abc_header_append(auxil, _17, 'T');
#undef _17e
#undef _17s
#undef _17
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Oheader_17(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _18 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[17])
#define _18s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[17]->range.start))
#define _18e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[17]->range.end))
    abc_header_append(auxil, _18, 'U');
#undef _18e
#undef _18s
#undef _18
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_KeySig_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_change_append(auxil, _1);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Unit_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_change_append(auxil, _1);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_TimeSig_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_change_append(auxil, _1);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Tempo_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_change_append(auxil, _1);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Vvalue_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_voice_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_NotePunct_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_notepunct_set(auxil, _1);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Instruction_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_instruction_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Lyrics_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_lyrics_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Tie_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_tie_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Grace_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_grace_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Grace_1(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
#define _2 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.end))
    abc_grace_append(auxil, _2);
#undef _2e
#undef _2s
#undef _2
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Chord_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_chord_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Chord_1(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
#define _2 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.end))
    abc_chord_append(auxil, _2);
#undef _2e
#undef _2s
#undef _2
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action___0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_space_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Decoration_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_deco_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ExDecoration_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_deco_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Nuplet_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define p (*__pcc_in->data.leaf.values.buf[0])
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
    abc_nuplet_append(auxil, p, 0, 0);
#undef _0e
#undef _0s
#undef _0
#undef p
#undef __
#undef auxil
}

static void pcc_action_Nuplet_1(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define p (*__pcc_in->data.leaf.values.buf[0])
#define q (*__pcc_in->data.leaf.values.buf[1])
#define r (*__pcc_in->data.leaf.values.buf[2])
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
    abc_nuplet_append(auxil, p, q, r);
#undef _0e
#undef _0s
#undef _0
#undef r
#undef q
#undef p
#undef __
#undef auxil
}

static void pcc_action_Nuplet_2(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define p (*__pcc_in->data.leaf.values.buf[0])
#define q (*__pcc_in->data.leaf.values.buf[1])
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
    abc_nuplet_append(auxil, p, q, 0);
#undef _0e
#undef _0s
#undef _0
#undef q
#undef p
#undef __
#undef auxil
}

static void pcc_action_Nuplet_3(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define p (*__pcc_in->data.leaf.values.buf[0])
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
    abc_nuplet_append(auxil, p, 0, 0);
#undef _0e
#undef _0s
#undef _0
#undef p
#undef __
#undef auxil
}

static void pcc_action_Digits_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    __ = atoi(_0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Gchord_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_gchord_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_SlurStart_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_slur_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_SlurEnd_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_slur_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_SimpleAlter_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_alt_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Alternative_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_alt_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Bar_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_bar_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Duration_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_duration_num_set(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Duration_1(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
#define _2 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.end))
    abc_duration_den_set(auxil, _2);
#undef _2e
#undef _2s
#undef _2
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Duration_2(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _3 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[2])
#define _3s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[2]->range.start))
#define _3e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[2]->range.end))
    abc_duration_num_set(auxil, _3);
#undef _3e
#undef _3s
#undef _3
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Duration_3(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _4 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[3])
#define _4s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[3]->range.start))
#define _4e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[3]->range.end))
    abc_duration_den_set(auxil, _4);
#undef _4e
#undef _4s
#undef _4
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Note_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    abc_note_append(auxil, _0);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_LineBreak_0(pcc_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)__pcc_in->data.leaf.capt0.range.start)
#define _0e ((const size_t)__pcc_in->data.leaf.capt0.range.end)
    abc_eol_append(auxil, _0);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TuneBook(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Tune(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Header(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Xheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Xvalue(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Kheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Oheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Score(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Fragment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InlineChange(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Change(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KeySig(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Unit(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TimeSig(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Tempo(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Comment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Vheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Vvalue(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NotePunct(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NoteConstruct(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Instruction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Lyrics(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Tie(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Grace(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Chord(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule__(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Decoration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExDecoration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Nuplet(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Digits(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Gchord(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SlurStart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SlurEnd(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SimpleAlter(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Alternative(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Bar(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Duration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Note(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EOL(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LineCont(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LineBreak(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EOF(pcc_context_t *ctx);

static pcc_thunk_chunk_t *pcc_evaluate_rule_TuneBook(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "TuneBook", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &chunk->thunks, NULL)) goto L0003;
                {
                    const size_t p0 = ctx->cur;
                    const size_t n0 = chunk->thunks.len;
                    int i;
                    for (i = 0;; i++) {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0004;
                        if (ctx->cur == p) break;
                        continue;
                    L0004:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        break;
                    }
                    if (i < 1) {
                        ctx->cur = p0;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                        goto L0003;
                    }
                }
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tune, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOF, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &chunk->thunks, NULL)) goto L0006;
                {
                    const size_t p0 = ctx->cur;
                    const size_t n0 = chunk->thunks.len;
                    int i;
                    for (i = 0;; i++) {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0007;
                        if (ctx->cur == p) break;
                        continue;
                    L0007:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        break;
                    }
                    if (i < 1) {
                        ctx->cur = p0;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                        goto L0006;
                    }
                }
                if (ctx->cur == p) break;
                continue;
            L0006:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tune, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TuneBook, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "TuneBook", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "TuneBook", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Tune(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Tune", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Xheader, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Header, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Kheader, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &chunk->thunks, NULL)) goto L0004;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0004;
            if (ctx->cur == p) break;
            continue;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Score, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Tune", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Tune", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Header(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Header", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Oheader, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Header", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Header", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Xheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Xheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->cur)[0] != 'X' ||
        (ctx->buffer.buf + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Xvalue, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Xheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Xheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Xvalue(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Xvalue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                (u >= 0x000031 && u <= 0x000039)
            )) goto L0000;
            ctx->cur += n;
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Xvalue_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Xvalue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Xvalue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Kheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Kheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->cur)[0] != 'K' ||
        (ctx->buffer.buf + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Kheader_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Kheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Kheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Oheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Oheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 18);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'A' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0002;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0004;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0003;
                    L0004:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0003;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0002;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_0, 0, 18);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'B' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0005;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0007;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0006;
                    L0007:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0006;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0006:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0005;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[1].range.start = p;
            chunk->capts.buf[1].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_1, 0, 18);
            thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'C' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0008;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0010;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0009;
                    L0010:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0009;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0009:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0008;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[2].range.start = p;
            chunk->capts.buf[2].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_2, 0, 18);
            thunk->data.leaf.capts.buf[2] = &(chunk->capts.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'D' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0011;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0013;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0012;
                    L0013:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0012;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0012:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0011;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[3].range.start = p;
            chunk->capts.buf[3].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_3, 0, 18);
            thunk->data.leaf.capts.buf[3] = &(chunk->capts.buf[3]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'F' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0014;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0016;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0015;
                    L0016:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0015;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0015:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0014;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[4].range.start = p;
            chunk->capts.buf[4].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_4, 0, 18);
            thunk->data.leaf.capts.buf[4] = &(chunk->capts.buf[4]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'G' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0017;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0019;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0018;
                    L0019:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0018;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0018:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0017;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[5].range.start = p;
            chunk->capts.buf[5].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_5, 0, 18);
            thunk->data.leaf.capts.buf[5] = &(chunk->capts.buf[5]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'H' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0020;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0022;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0021;
                    L0022:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0021;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0021:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0020;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[6].range.start = p;
            chunk->capts.buf[6].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_6, 0, 18);
            thunk->data.leaf.capts.buf[6] = &(chunk->capts.buf[6]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0020:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'I' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0023;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0025;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0024;
                    L0025:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0024;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0024:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0023;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[7].range.start = p;
            chunk->capts.buf[7].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_7, 0, 18);
            thunk->data.leaf.capts.buf[7] = &(chunk->capts.buf[7]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0023:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'L' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0026;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0028;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0027;
                    L0028:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0027;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0027:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0026;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[8].range.start = p;
            chunk->capts.buf[8].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_8, 0, 18);
            thunk->data.leaf.capts.buf[8] = &(chunk->capts.buf[8]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0026:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'M' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0029;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0031;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0030;
                    L0031:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0030;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0030:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0029;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[9].range.start = p;
            chunk->capts.buf[9].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_9, 0, 18);
            thunk->data.leaf.capts.buf[9] = &(chunk->capts.buf[9]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0029:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'N' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0032;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0034;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0033;
                    L0034:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0033;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0033:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0032;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[10].range.start = p;
            chunk->capts.buf[10].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_10, 0, 18);
            thunk->data.leaf.capts.buf[10] = &(chunk->capts.buf[10]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0032:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'O' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0035;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0037;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0036;
                    L0037:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0036;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0036:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0035;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[11].range.start = p;
            chunk->capts.buf[11].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_11, 0, 18);
            thunk->data.leaf.capts.buf[11] = &(chunk->capts.buf[11]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0035:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'P' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0038;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0040;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0039;
                    L0040:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0039;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0039:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0038;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[12].range.start = p;
            chunk->capts.buf[12].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_12, 0, 18);
            thunk->data.leaf.capts.buf[12] = &(chunk->capts.buf[12]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0038:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'Q' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0041;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0043;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0042;
                    L0043:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0042;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0042:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0041;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[13].range.start = p;
            chunk->capts.buf[13].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_13, 0, 18);
            thunk->data.leaf.capts.buf[13] = &(chunk->capts.buf[13]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0041:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'R' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0044;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0046;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0045;
                    L0046:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0045;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0045:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0044;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[14].range.start = p;
            chunk->capts.buf[14].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_14, 0, 18);
            thunk->data.leaf.capts.buf[14] = &(chunk->capts.buf[14]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0044:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'S' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0047;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0049;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0048;
                    L0049:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0048;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0048:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0047;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[15].range.start = p;
            chunk->capts.buf[15].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_15, 0, 18);
            thunk->data.leaf.capts.buf[15] = &(chunk->capts.buf[15]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0047:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'T' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0050;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0052;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0051;
                    L0052:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0051;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0051:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0050;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[16].range.start = p;
            chunk->capts.buf[16].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_16, 0, 18);
            thunk->data.leaf.capts.buf[16] = &(chunk->capts.buf[16]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0050:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'U' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0053;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0055;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0054;
                    L0055:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0054;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0054:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0053;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[17].range.start = p;
            chunk->capts.buf[17].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Oheader_17, 0, 18);
            thunk->data.leaf.capts.buf[17] = &(chunk->capts.buf[17]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0053:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Oheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Oheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Score(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Score", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Vheader, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Fragment, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0002;
            }
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Score, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Fragment, &chunk->thunks, NULL)) goto L0006;
                if (ctx->cur == p) break;
                continue;
            L0006:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0005;
            }
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Score", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Score", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Fragment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Fragment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != 'y'
        ) goto L0003;
        ctx->cur++;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != '%' ||
            (ctx->buffer.buf + ctx->cur)[1] != '%'
        ) goto L0004;
        ctx->cur += 2;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Instruction, &chunk->thunks, NULL)) goto L0004;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InlineChange, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Change, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &chunk->thunks, NULL)) goto L0007;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NotePunct, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '\"'
        ) goto L0010;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Gchord, &chunk->thunks, NULL)) goto L0010;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '\"'
        ) goto L0010;
        ctx->cur++;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '!'
        ) goto L0011;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExDecoration, &chunk->thunks, NULL)) goto L0011;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '!'
        ) goto L0011;
        ctx->cur++;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Decoration, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Chord, &chunk->thunks, NULL)) goto L0013;
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tie, &chunk->thunks, NULL)) goto L0014;
                if (ctx->cur == p) break;
                continue;
            L0014:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Grace, &chunk->thunks, NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '('
        ) goto L0016;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Nuplet, &chunk->thunks, NULL)) goto L0016;
        goto L0001;
    L0016:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SlurStart, &chunk->thunks, NULL)) goto L0017;
        goto L0001;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SlurEnd, &chunk->thunks, NULL)) goto L0018;
        goto L0001;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Bar, &chunk->thunks, NULL)) goto L0019;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SimpleAlter, &chunk->thunks, NULL)) goto L0019;
        goto L0001;
    L0019:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Bar, &chunk->thunks, NULL)) goto L0020;
        goto L0001;
    L0020:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alternative, &chunk->thunks, NULL)) goto L0021;
        goto L0001;
    L0021:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LineCont, &chunk->thunks, NULL)) goto L0022;
        goto L0001;
    L0022:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LineBreak, &chunk->thunks, NULL)) goto L0023;
        goto L0001;
    L0023:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'w' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0024;
        ctx->cur += 2;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Lyrics, &chunk->thunks, NULL)) goto L0024;
        goto L0001;
    L0024:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Fragment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Fragment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InlineChange(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "InlineChange", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '['
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Change, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != ']'
    ) goto L0000;
    ctx->cur++;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "InlineChange", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "InlineChange", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Change(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Change", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KeySig, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Unit, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TimeSig, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tempo, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Change", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Change", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KeySig(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "KeySig", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'K' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->cur] != ']'
                    ) goto L0003;
                    ctx->cur++;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_KeySig_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "KeySig", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "KeySig", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Unit(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Unit", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'L' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->cur] != ']'
                    ) goto L0003;
                    ctx->cur++;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Unit_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Unit", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Unit", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TimeSig(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "TimeSig", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'M' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->cur] != ']'
                    ) goto L0003;
                    ctx->cur++;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_TimeSig_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "TimeSig", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "TimeSig", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Tempo(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Tempo", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != 'Q' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->cur] != ']'
                    ) goto L0003;
                    ctx->cur++;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Tempo_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Tempo", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Tempo", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Comment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Comment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '%'
        ) goto L0002;
        ctx->cur++;
        {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '%'
            ) goto L0003;
            ctx->cur++;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0002;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0005;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0004;
                L0005:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0004;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '%'
        ) goto L0006;
        ctx->cur++;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '%'
        ) goto L0006;
        ctx->cur++;
        {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0007;
                if (!(
                    (u >= 0x000041 && u <= 0x00005a)
                )) goto L0007;
                ctx->cur += n;
            }
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0006;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0009;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0008;
                L0009:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0008;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0008:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Comment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Comment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Vheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Vheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->cur)[0] != 'V' ||
        (ctx->buffer.buf + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Vvalue, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Vheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Vheader", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Vvalue(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Vvalue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Vvalue_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Vvalue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Vvalue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NotePunct(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "NotePunct", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->cur] != '>'
                    ) goto L0004;
                    ctx->cur++;
                    goto L0003;
                L0004:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->cur] != '<'
                    ) goto L0005;
                    ctx->cur++;
                    goto L0003;
                L0005:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0002;
                L0003:;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0006;
            if (ctx->cur == p) break;
            continue;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_NotePunct_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "NotePunct", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "NotePunct", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NoteConstruct(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "NoteConstruct", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '!'
            ) goto L0001;
            ctx->cur++;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExDecoration, &chunk->thunks, NULL)) goto L0001;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '!'
            ) goto L0001;
            ctx->cur++;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Decoration, &chunk->thunks, NULL)) goto L0002;
            if (ctx->cur == p) break;
            continue;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Note, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Duration, &chunk->thunks, NULL)) goto L0003;
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tie, &chunk->thunks, NULL)) goto L0004;
            if (ctx->cur == p) break;
            continue;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "NoteConstruct", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "NoteConstruct", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Instruction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Instruction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '%'
            ) goto L0001;
            ctx->cur++;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0000;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0003;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0002;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Instruction_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Instruction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Instruction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Lyrics(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Lyrics", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0002;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Lyrics_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Lyrics", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Tie(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Tie", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '-'
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Tie_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Tie", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Tie", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Grace(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Grace", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 2);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 2) < 2 ||
                (ctx->buffer.buf + ctx->cur)[0] != '{' ||
                (ctx->buffer.buf + ctx->cur)[1] != '/'
            ) goto L0002;
            ctx->cur += 2;
            goto L0001;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '{'
            ) goto L0003;
            ctx->cur++;
            goto L0001;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0000;
        L0001:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Grace_0, 0, 2);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &chunk->thunks, NULL)) goto L0004;
            if (ctx->cur == p) break;
            continue;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
            goto L0000;
        }
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '}'
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.buf[1].range.start = p;
        chunk->capts.buf[1].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Grace_1, 0, 2);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Grace", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Grace", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Chord(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Chord", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 2);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '['
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Chord_0, 0, 2);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
            goto L0000;
        }
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != ']'
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.buf[1].range.start = p;
        chunk->capts.buf[1].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Chord_1, 0, 2);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Chord", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Chord", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule__(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "_", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                u == 0x000020 ||
                u == 0x000009
            )) goto L0000;
            ctx->cur += n;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action___0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "_", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "_", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Decoration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Decoration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '.'
            ) goto L0002;
            ctx->cur++;
            goto L0001;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '~'
            ) goto L0003;
            ctx->cur++;
            goto L0001;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'H'
            ) goto L0004;
            ctx->cur++;
            goto L0001;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'L'
            ) goto L0005;
            ctx->cur++;
            goto L0001;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'M'
            ) goto L0006;
            ctx->cur++;
            goto L0001;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'O'
            ) goto L0007;
            ctx->cur++;
            goto L0001;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'P'
            ) goto L0008;
            ctx->cur++;
            goto L0001;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'S'
            ) goto L0009;
            ctx->cur++;
            goto L0001;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'T'
            ) goto L0010;
            ctx->cur++;
            goto L0001;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'u'
            ) goto L0011;
            ctx->cur++;
            goto L0001;
        L0011:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != 'v'
            ) goto L0012;
            ctx->cur++;
            goto L0001;
        L0012:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0000;
        L0001:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Decoration_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Decoration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Decoration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExDecoration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "ExDecoration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (
                        u == 0x000021
                    ) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_ExDecoration_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "ExDecoration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "ExDecoration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Nuplet(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Nuplet", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 3);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &chunk->thunks, &(chunk->values.buf[0]))) goto L0002;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != ':' ||
            (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0002;
        ctx->cur += 2;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Nuplet_0, 3, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &chunk->thunks, &(chunk->values.buf[0]))) goto L0003;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != ':'
        ) goto L0003;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &chunk->thunks, &(chunk->values.buf[1]))) goto L0003;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != ':'
        ) goto L0003;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &chunk->thunks, &(chunk->values.buf[2]))) goto L0003;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Nuplet_1, 3, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &chunk->thunks, &(chunk->values.buf[0]))) goto L0004;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != ':'
        ) goto L0004;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &chunk->thunks, &(chunk->values.buf[1]))) goto L0004;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Nuplet_2, 3, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &chunk->thunks, &(chunk->values.buf[0]))) goto L0005;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Nuplet_3, 3, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Nuplet", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Nuplet", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Digits(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Digits", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Digits_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Digits", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Digits", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Gchord(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Gchord", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                (u >= 0x000041 && u <= 0x000048)
            )) goto L0000;
            ctx->cur += n;
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (
                        u == 0x000022
                    ) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Gchord_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Gchord", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Gchord", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SlurStart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "SlurStart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '('
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_SlurStart_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "SlurStart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "SlurStart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SlurEnd(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "SlurEnd", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != ')'
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_SlurEnd_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "SlurEnd", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "SlurEnd", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SimpleAlter(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "SimpleAlter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        (u >= 0x000031 && u <= 0x000039)
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (!(
                        u == 0x00002d ||
                        u == 0x00002c
                    )) goto L0002;
                    ctx->cur += n;
                }
                {
                    const size_t p0 = ctx->cur;
                    const size_t n0 = chunk->thunks.len;
                    int i;
                    for (i = 0;; i++) {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        {
                            int u;
                            const size_t n = pcc_get_char_as_utf32(ctx, &u);
                            if (n == 0) goto L0003;
                            if (!(
                                (u >= 0x000031 && u <= 0x000039)
                            )) goto L0003;
                            ctx->cur += n;
                        }
                        if (ctx->cur == p) break;
                        continue;
                    L0003:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        break;
                    }
                    if (i < 1) {
                        ctx->cur = p0;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                        goto L0002;
                    }
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_SimpleAlter_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "SimpleAlter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "SimpleAlter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Alternative(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Alternative", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '['
        ) goto L0000;
        ctx->cur++;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        (u >= 0x000031 && u <= 0x000039)
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (!(
                        u == 0x00002d ||
                        u == 0x00002c
                    )) goto L0002;
                    ctx->cur += n;
                }
                {
                    const size_t p0 = ctx->cur;
                    const size_t n0 = chunk->thunks.len;
                    int i;
                    for (i = 0;; i++) {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.len;
                        {
                            int u;
                            const size_t n = pcc_get_char_as_utf32(ctx, &u);
                            if (n == 0) goto L0003;
                            if (!(
                                (u >= 0x000031 && u <= 0x000039)
                            )) goto L0003;
                            ctx->cur += n;
                        }
                        if (ctx->cur == p) break;
                        continue;
                    L0003:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        break;
                    }
                    if (i < 1) {
                        ctx->cur = p0;
                        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                        goto L0002;
                    }
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Alternative_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Alternative", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Alternative", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Bar(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Bar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '['
            ) goto L0001;
            ctx->cur++;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0002:;
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0003;
                    if (!(
                        u == 0x00003a ||
                        u == 0x00007c ||
                        u == 0x00005d
                    )) goto L0003;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Bar_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Bar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Bar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Duration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Duration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 4);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0003;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0003;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
        }
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '/'
        ) goto L0002;
        ctx->cur++;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Duration_0, 0, 4);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0002;
                if (!(
                    (u >= 0x000031 && u <= 0x000039)
                )) goto L0002;
                ctx->cur += n;
            }
            {
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0004;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0004;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0004:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[1].range.start = p;
            chunk->capts.buf[1].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Duration_1, 0, 4);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0006;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0006;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0006:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0005;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[2].range.start = p;
            chunk->capts.buf[2].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Duration_2, 0, 4);
            thunk->data.leaf.capts.buf[2] = &(chunk->capts.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->cur] != '/'
                    ) goto L0008;
                    ctx->cur++;
                    if (ctx->cur == p) break;
                    continue;
                L0008:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0007;
                }
            }
            q = ctx->cur;
            chunk->capts.buf[3].range.start = p;
            chunk->capts.buf[3].range.end = q;
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Duration_3, 0, 4);
            thunk->data.leaf.capts.buf[3] = &(chunk->capts.buf[3]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Duration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Duration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Note(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "Note", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        u == 0x00005f ||
                        u == 0x00003d ||
                        u == 0x00005e
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                (u >= 0x000041 && u <= 0x000047) ||
                (u >= 0x000061 && u <= 0x000067) ||
                u == 0x00005a ||
                u == 0x00007a
            )) goto L0000;
            ctx->cur += n;
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (!(
                        u == 0x00002c ||
                        u == 0x000027
                    )) goto L0002;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_Note_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "Note", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "Note", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EOL(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "EOL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != '\r' ||
            (ctx->buffer.buf + ctx->cur)[1] != '\n'
        ) goto L0002;
        ctx->cur += 2;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '\r'
        ) goto L0003;
        ctx->cur++;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '\n'
        ) goto L0004;
        ctx->cur++;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "EOL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "EOL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LineCont(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "LineCont", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '\\'
    ) goto L0000;
    ctx->cur++;
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "LineCont", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "LineCont", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LineBreak(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "LineBreak", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->cur)[0] != '\r' ||
            (ctx->buffer.buf + ctx->cur)[1] != '\n'
        ) goto L0002;
        ctx->cur += 2;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '\r'
        ) goto L0003;
        ctx->cur++;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '\n'
        ) goto L0004;
        ctx->cur++;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx->auxil, pcc_action_LineBreak_0, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "LineBreak", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "LineBreak", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EOF(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->cur;
    PCC_DEBUG(PCC_DBG_EVALUATE, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->cur;
        const size_t n = chunk->thunks.len;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    }
    ctx->level--;
    PCC_DEBUG(PCC_DBG_MATCH, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(PCC_DBG_NOMATCH, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

pcc_context_t *pcc_create(struct abc *auxil) {
    return pcc_context__create(auxil);
}

int pcc_parse(pcc_context_t *ctx, int *ret) {
    pcc_thunk_array_t thunks;
    pcc_thunk_array__init(ctx->auxil, &thunks, PCC_ARRAYSIZE);
    if (pcc_apply_rule(ctx, pcc_evaluate_rule_TuneBook, &thunks, ret))
        pcc_do_action(ctx, &thunks, ret);
    else
        PCC_ERROR(ctx->auxil);
    pcc_commit_buffer(ctx);
    pcc_thunk_array__term(ctx->auxil, &thunks);
    return pcc_refill_buffer(ctx, 1) >= 1;
}

void pcc_destroy(pcc_context_t *ctx) {
    pcc_context__destroy(ctx);
}
