/* A parser generated by PackCC 3.0.0 */

#define _GNU_SOURCE
#include <stdio.h>

#ifdef _MSC_VER
#undef _CRT_NONSTDC_NO_WARNINGS
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_NONSTDC_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "parser.h"

#include "abc.h"

#define PCC_GETCHAR(auxil) get_char(auxil)
static int get_char(struct abc* auxil) {
        if (auxil->error)
                return -1;

        if (auxil->buffer->count == auxil->buffer->index)
                return -1;

        return auxil->buffer->buf[auxil->buffer->index++];
}

#define PCC_ERROR(auxil) gen_error(auxil)
static void gen_error(struct abc* auxil) {
        int line = 1;
        int l = 0;
        for (int i = 0; i < auxil->buffer->index; i++) {
                if (auxil->buffer->buf[i] == '\n') {
                        line++;
                        l = i + 1;
                }
        }

        auxil->error = 1;
        auxil->error_line = line;
        auxil->error_char = auxil->buffer->index - l;
}

#if !defined __has_attribute || defined _MSC_VER
#define __attribute__(x)
#endif

#ifdef _MSC_VER
#define MARK_FUNC_AS_USED __pragma(warning(suppress:4505))
#else
#define MARK_FUNC_AS_USED __attribute__((__unused__))
#endif

#ifdef _MSC_VER
#define MARK_VAR_AS_USED __pragma(warning(suppress:4189))
#else
#define MARK_VAR_AS_USED __attribute__((__unused__))
#endif

#ifndef PCC_BUFFER_MIN_SIZE
#define PCC_BUFFER_MIN_SIZE 256
#endif /* !PCC_BUFFER_MIN_SIZE */

#ifndef PCC_ARRAY_MIN_SIZE
#define PCC_ARRAY_MIN_SIZE 2
#endif /* !PCC_ARRAY_MIN_SIZE */

#ifndef PCC_THUNK_ARRAY_MIN_SIZE
#define PCC_THUNK_ARRAY_MIN_SIZE 2
#endif /* !PCC_THUNK_ARRAY_MIN_SIZE */

#ifndef PCC_LR_MEMO_MAP_MIN_SIZE
#define PCC_LR_MEMO_MAP_MIN_SIZE 4
#endif /* !PCC_LR_MEMO_MAP_MIN_SIZE */

#ifndef PCC_POOL_MIN_SIZE
#define PCC_POOL_MIN_SIZE 65536
#endif /* !PCC_POOL_MIN_SIZE */

#define PCC_DBG_EVALUATE 0
#define PCC_DBG_MATCH    1
#define PCC_DBG_NOMATCH  2

#define PCC_VOID_VALUE (~(size_t)0)

typedef enum pcc_bool_tag {
    PCC_FALSE = 0,
    PCC_TRUE
} pcc_bool_t;

typedef struct pcc_char_array_tag {
    size_t m, n;
    char *p;
} pcc_char_array_t;

typedef struct pcc_range_tag {
    size_t start;
    size_t end;
} pcc_range_t;

typedef char pcc_value_t;

typedef struct abc *pcc_auxil_t;

typedef struct pcc_value_table_tag {
    size_t m, n;
    pcc_value_t *p;
} pcc_value_table_t;

typedef struct pcc_value_refer_table_tag {
    size_t m, n;
    pcc_value_t **p;
} pcc_value_refer_table_t;

typedef struct pcc_capture_tag {
    pcc_range_t range;
    pcc_char_array_t string; /* mutable */
} pcc_capture_t;

typedef struct pcc_capture_table_tag {
    size_t m, n;
    pcc_capture_t *p;
} pcc_capture_table_t;

typedef struct pcc_capture_const_table_tag {
    size_t m, n;
    const pcc_capture_t **p;
} pcc_capture_const_table_t;

typedef struct pcc_thunk_tag pcc_thunk_t;
typedef struct pcc_thunk_array_tag pcc_thunk_array_t;

typedef void (*pcc_action_t)(pcc_context_t *, pcc_thunk_t *, pcc_value_t *);

typedef enum pcc_thunk_type_tag {
    PCC_THUNK_LEAF,
    PCC_THUNK_NODE
} pcc_thunk_type_t;

typedef struct pcc_thunk_leaf_tag {
    pcc_value_refer_table_t values;
    pcc_capture_const_table_t capts;
    pcc_capture_t capt0;
    pcc_action_t action;
} pcc_thunk_leaf_t;

typedef struct pcc_thunk_node_tag {
    const pcc_thunk_array_t *thunks; /* just a reference */
    pcc_value_t *value; /* just a reference */
} pcc_thunk_node_t;

typedef union pcc_thunk_data_tag {
    pcc_thunk_leaf_t leaf;
    pcc_thunk_node_t node;
} pcc_thunk_data_t;

struct pcc_thunk_tag {
    pcc_thunk_type_t type;
    pcc_thunk_data_t data;
};

struct pcc_thunk_array_tag {
    size_t m, n;
    pcc_thunk_t **p;
    pcc_thunk_t *a[PCC_THUNK_ARRAY_MIN_SIZE]; /* for reducing memory allocation frequency */
};

typedef struct pcc_thunk_chunk_tag {
    pcc_value_table_t values;
    pcc_capture_table_t capts;
    pcc_thunk_array_t thunks;
    size_t pos; /* the starting position in the character buffer */
} pcc_thunk_chunk_t;

typedef struct pcc_lr_entry_tag pcc_lr_entry_t;

typedef enum pcc_lr_answer_type_tag {
    PCC_LR_ANSWER_LR,
    PCC_LR_ANSWER_CHUNK
} pcc_lr_answer_type_t;

typedef union pcc_lr_answer_data_tag {
    pcc_lr_entry_t *lr;
    pcc_thunk_chunk_t *chunk;
} pcc_lr_answer_data_t;

typedef struct pcc_lr_answer_tag pcc_lr_answer_t;

struct pcc_lr_answer_tag {
    pcc_lr_answer_type_t type;
    pcc_lr_answer_data_t data;
    size_t pos; /* the absolute position in the input */
    pcc_lr_answer_t *hold;
};

typedef pcc_thunk_chunk_t *(*pcc_rule_t)(pcc_context_t *);

typedef struct pcc_rule_set_tag {
    size_t m, n;
    pcc_rule_t *p;
} pcc_rule_set_t;

typedef struct pcc_lr_head_tag pcc_lr_head_t;

struct pcc_lr_head_tag {
    pcc_rule_t rule;
    pcc_rule_set_t invol;
    pcc_rule_set_t eval;
    pcc_lr_head_t *hold;
};

typedef struct pcc_lr_memo_tag {
    pcc_rule_t rule;
    pcc_lr_answer_t *answer;
} pcc_lr_memo_t;

typedef struct pcc_lr_memo_map_tag {
    size_t m, n;
    pcc_lr_memo_t *p;
    pcc_lr_memo_t a[PCC_LR_MEMO_MAP_MIN_SIZE]; /* for reducing memory allocation frequency */
} pcc_lr_memo_map_t;

typedef struct pcc_lr_table_entry_tag {
    pcc_lr_head_t *head; /* just a reference */
    pcc_lr_memo_map_t memos;
    pcc_lr_answer_t *hold_a;
    pcc_lr_head_t *hold_h;
} pcc_lr_table_entry_t;

typedef struct pcc_lr_table_tag {
    size_t m, n;
    size_t o;
    pcc_lr_table_entry_t **p;
} pcc_lr_table_t;

struct pcc_lr_entry_tag {
    pcc_rule_t rule;
    pcc_thunk_chunk_t *seed; /* just a reference */
    pcc_lr_head_t *head; /* just a reference */
};

typedef struct pcc_lr_stack_tag {
    size_t m, n;
    pcc_lr_entry_t **p;
} pcc_lr_stack_t;

typedef struct pcc_memory_entry_tag pcc_memory_entry_t;
typedef struct pcc_memory_pool_tag pcc_memory_pool_t;

struct pcc_memory_entry_tag {
    pcc_memory_entry_t *next;
};

struct pcc_memory_pool_tag {
    pcc_memory_pool_t *next;
    size_t allocated;
    size_t unused;
};

typedef struct pcc_memory_recycler_tag {
    pcc_memory_pool_t *pool_list;
    pcc_memory_entry_t *entry_list;
    size_t element_size;
} pcc_memory_recycler_t;

struct pcc_context_tag {
    size_t pos; /* the position in the input of the first character currently buffered */
    size_t cur; /* the current parsing position in the character buffer */
    size_t level;
    pcc_char_array_t buffer;
    pcc_lr_table_t lrtable;
    pcc_lr_stack_t lrstack;
    pcc_thunk_array_t thunks;
    pcc_capture_t capt0; /* used only for programmable predicates */
    pcc_auxil_t auxil;
    pcc_memory_recycler_t thunk_recycler;
    pcc_memory_recycler_t thunk_chunk_recycler;
    pcc_memory_recycler_t lr_head_recycler;
    pcc_memory_recycler_t lr_answer_recycler;
    pcc_memory_recycler_t lr_table_entry_recycler;
    pcc_memory_recycler_t lr_entry_recycler;
};

#ifndef PCC_ERROR
#define PCC_ERROR(auxil) pcc_error()
MARK_FUNC_AS_USED
static void pcc_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PCC_ERROR */

#ifndef PCC_GETCHAR
#define PCC_GETCHAR(auxil) getchar()
#endif /* !PCC_GETCHAR */

#ifndef PCC_MALLOC
#define PCC_MALLOC(auxil, size) pcc_malloc_e(size)
static void *pcc_malloc_e(size_t size) {
    void *const p = malloc(size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_MALLOC */

#ifndef PCC_REALLOC
#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)
static void *pcc_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_REALLOC */

#ifndef PCC_FREE
#define PCC_FREE(auxil, ptr) free(ptr)
#endif /* !PCC_FREE */

#ifndef PCC_DEBUG
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) ((void)0)
#endif /* !PCC_DEBUG */

static void pcc_char_array__initialize(pcc_auxil_t auxil, pcc_char_array_t *obj) {
    obj->m = 0;
    obj->n = 0;
    obj->p = NULL;
}

static void pcc_char_array__finalize(pcc_auxil_t auxil, pcc_char_array_t *obj) {
    PCC_FREE(auxil, obj->p);
}

static void pcc_char_array__resize(pcc_auxil_t auxil, pcc_char_array_t *obj, size_t len) {
    if (obj->m < len) {
        size_t m = obj->m;
        if (m == 0) m = PCC_BUFFER_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        obj->p = (char *)PCC_REALLOC(auxil, obj->p, m);
        obj->m = m;
    }
    obj->n = len;
}

static void pcc_char_array__add(pcc_auxil_t auxil, pcc_char_array_t *obj, char ch) {
    if (obj->m <= obj->n) {
        const size_t n = obj->n + 1;
        size_t m = obj->m;
        if (m == 0) m = PCC_BUFFER_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        obj->p = (char *)PCC_REALLOC(auxil, obj->p, m);
        obj->m = m;
    }
    obj->p[obj->n++] = ch;
}

MARK_FUNC_AS_USED
static void pcc_char_array__copy(pcc_auxil_t auxil, pcc_char_array_t *obj, const pcc_char_array_t *src) {
    if (obj == src) return;
    pcc_char_array__resize(auxil, obj, src->n);
    memcpy(obj->p, src->p, src->n);
}

static void pcc_value_table__initialize(pcc_auxil_t auxil, pcc_value_table_t *obj) {
    obj->m = 0;
    obj->n = 0;
    obj->p = NULL;
}

static void pcc_value_table__finalize(pcc_auxil_t auxil, pcc_value_table_t *obj) {
    PCC_FREE(auxil, obj->p);
}

MARK_FUNC_AS_USED
static void pcc_value_table__clear(pcc_auxil_t auxil, pcc_value_table_t *obj) {
    memset(obj->p, 0, sizeof(pcc_value_t) * obj->n);
}

MARK_FUNC_AS_USED
static void pcc_value_table__resize(pcc_auxil_t auxil, pcc_value_table_t *obj, size_t len) {
    if (obj->m < len) {
        size_t m = obj->m;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        obj->p = (pcc_value_t *)PCC_REALLOC(auxil, obj->p, sizeof(pcc_value_t) * m);
        obj->m = m;
    }
    obj->n = len;
}

static void pcc_value_refer_table__initialize(pcc_auxil_t auxil, pcc_value_refer_table_t *obj) {
    obj->m = 0;
    obj->n = 0;
    obj->p = NULL;
}

static void pcc_value_refer_table__finalize(pcc_auxil_t auxil, pcc_value_refer_table_t *obj) {
    PCC_FREE(auxil, obj->p);
}

static void pcc_value_refer_table__resize(pcc_auxil_t auxil, pcc_value_refer_table_t *obj, size_t len) {
    size_t i;
    if (obj->m < len) {
        size_t m = obj->m;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        obj->p = (pcc_value_t **)PCC_REALLOC(auxil, obj->p, sizeof(pcc_value_t *) * m);
        obj->m = m;
    }
    for (i = obj->n; i < len; i++) obj->p[i] = NULL;
    obj->n = len;
}

static void pcc_capture__initialize(pcc_auxil_t auxil, pcc_capture_t *obj) {
    obj->range.start = 0;
    obj->range.end = 0;
    pcc_char_array__initialize(auxil, &(obj->string));
}

static void pcc_capture__finalize(pcc_auxil_t auxil, pcc_capture_t *obj) {
    pcc_char_array__finalize(auxil, &(obj->string));
}

static void pcc_capture_table__initialize(pcc_auxil_t auxil, pcc_capture_table_t *obj) {
    obj->m = 0;
    obj->n = 0;
    obj->p = NULL;
}

static void pcc_capture_table__finalize(pcc_auxil_t auxil, pcc_capture_table_t *obj) {
    while (obj->n > 0) {
        obj->n--;
        pcc_capture__finalize(auxil, &(obj->p[obj->n]));
    }
    PCC_FREE(auxil, obj->p);
}

MARK_FUNC_AS_USED
static void pcc_capture_table__resize(pcc_auxil_t auxil, pcc_capture_table_t *obj, size_t len) {
    size_t i;
    for (i = len; i < obj->n; i++) pcc_capture__finalize(auxil, &(obj->p[i]));
    if (obj->m < len) {
        size_t m = obj->m;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        obj->p = (pcc_capture_t *)PCC_REALLOC(auxil, obj->p, sizeof(pcc_capture_t) * m);
        obj->m = m;
    }
    for (i = obj->n; i < len; i++) pcc_capture__initialize(auxil, &(obj->p[i]));
    obj->n = len;
}

static void pcc_capture_const_table__initialize(pcc_auxil_t auxil, pcc_capture_const_table_t *obj) {
    obj->m = 0;
    obj->n = 0;
    obj->p = NULL;
}

static void pcc_capture_const_table__finalize(pcc_auxil_t auxil, pcc_capture_const_table_t *obj) {
    PCC_FREE(auxil, (void *)obj->p);
}

static void pcc_capture_const_table__resize(pcc_auxil_t auxil, pcc_capture_const_table_t *obj, size_t len) {
    size_t i;
    if (obj->m < len) {
        size_t m = obj->m;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        obj->p = (const pcc_capture_t **)PCC_REALLOC(auxil, (pcc_capture_t **)obj->p, sizeof(const pcc_capture_t *) * m);
        obj->m = m;
    }
    for (i = obj->n; i < len; i++) obj->p[i] = NULL;
    obj->n = len;
}

static void pcc_memory_recycler__initialize(pcc_auxil_t auxil, pcc_memory_recycler_t *obj, size_t element_size) {
    obj->pool_list = NULL;
    obj->entry_list = NULL;
    obj->element_size = element_size;
}

static void pcc_memory_recycler__finalize(pcc_auxil_t auxil, pcc_memory_recycler_t *obj) {
    while (obj->pool_list) {
        pcc_memory_pool_t *const pool = obj->pool_list;
        obj->pool_list = pool->next;
        PCC_FREE(auxil, pool);
    }
}

static void *pcc_memory_recycler__supply(pcc_auxil_t auxil, pcc_memory_recycler_t *obj) {
    if (obj->entry_list) {
        pcc_memory_entry_t *const tmp = obj->entry_list;
        obj->entry_list = tmp->next;
        return tmp;
    }
    if (!obj->pool_list || obj->pool_list->unused == 0) {
        size_t size = PCC_POOL_MIN_SIZE;
        if (obj->pool_list) {
            size = obj->pool_list->allocated << 1;
            if (size == 0) size = obj->pool_list->allocated;
        }
        {
            pcc_memory_pool_t *const pool = (pcc_memory_pool_t *)PCC_MALLOC(
                auxil, sizeof(pcc_memory_pool_t) + obj->element_size * size
            );
            pool->allocated = size;
            pool->unused = size;
            pool->next = obj->pool_list;
            obj->pool_list = pool;
        }
    }
    obj->pool_list->unused--;
    return (char *)(obj->pool_list + 1) + obj->element_size * obj->pool_list->unused;
}

static void pcc_memory_recycler__recycle(pcc_auxil_t auxil, pcc_memory_recycler_t *obj, void *ptr) {
    pcc_memory_entry_t *const tmp = (pcc_memory_entry_t *)ptr;
    if (tmp == NULL) return;
    tmp->next = obj->entry_list;
    obj->entry_list = tmp;
}

MARK_FUNC_AS_USED
static pcc_thunk_t *pcc_thunk__create_leaf(pcc_context_t *ctx, pcc_action_t action, size_t valuec, size_t captc) {
    pcc_thunk_t *const obj = (pcc_thunk_t *)pcc_memory_recycler__supply(ctx->auxil, &(ctx->thunk_recycler));
    obj->type = PCC_THUNK_LEAF;
    pcc_value_refer_table__initialize(ctx->auxil, &(obj->data.leaf.values));
    pcc_value_refer_table__resize(ctx->auxil, &(obj->data.leaf.values), valuec);
    pcc_capture_const_table__initialize(ctx->auxil, &(obj->data.leaf.capts));
    pcc_capture_const_table__resize(ctx->auxil, &(obj->data.leaf.capts), captc);
    pcc_capture__initialize(ctx->auxil, &(obj->data.leaf.capt0));
    obj->data.leaf.action = action;
    return obj;
}

static pcc_thunk_t *pcc_thunk__create_node(pcc_context_t *ctx, const pcc_thunk_array_t *thunks, pcc_value_t *value) {
    pcc_thunk_t *const obj = (pcc_thunk_t *)pcc_memory_recycler__supply(ctx->auxil, &(ctx->thunk_recycler));
    obj->type = PCC_THUNK_NODE;
    obj->data.node.thunks = thunks;
    obj->data.node.value = value;
    return obj;
}

static void pcc_thunk__destroy(pcc_context_t *ctx, pcc_thunk_t *obj) {
    if (obj == NULL) return;
    switch (obj->type) {
    case PCC_THUNK_LEAF:
        pcc_value_refer_table__finalize(ctx->auxil, &(obj->data.leaf.values));
        pcc_capture_const_table__finalize(ctx->auxil, &(obj->data.leaf.capts));
        pcc_capture__finalize(ctx->auxil, &(obj->data.leaf.capt0));
        break;
    case PCC_THUNK_NODE:
        break;
    default: /* unknown */
        break;
    }
    pcc_memory_recycler__recycle(ctx->auxil, &(ctx->thunk_recycler), obj);
}

static void pcc_thunk_array__initialize(pcc_context_t *ctx, pcc_thunk_array_t *obj) {
    obj->m = PCC_THUNK_ARRAY_MIN_SIZE;
    obj->n = 0;
    obj->p = obj->a;
}

static void pcc_thunk_array__finalize(pcc_context_t *ctx, pcc_thunk_array_t *obj) {
    while (obj->n > 0) {
        obj->n--;
        pcc_thunk__destroy(ctx, obj->p[obj->n]);
    }
    if (obj->p != obj->a) PCC_FREE(ctx->auxil, obj->p);
}

static void pcc_thunk_array__add(pcc_context_t *ctx, pcc_thunk_array_t *obj, pcc_thunk_t *thunk) {
    if (obj->m <= obj->n) {
        const size_t n = obj->n + 1;
        size_t m = obj->m;
        if (m == 0) m = PCC_THUNK_ARRAY_MIN_SIZE << 1;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        if (obj->p == obj->a) {
            size_t i;
            obj->p = (pcc_thunk_t **)PCC_MALLOC(ctx->auxil, sizeof(pcc_thunk_t *) * m);
            for (i = 0; i < PCC_THUNK_ARRAY_MIN_SIZE; i++) obj->p[i] = obj->a[i];
        }
        else {
            obj->p = (pcc_thunk_t **)PCC_REALLOC(ctx->auxil, obj->p, sizeof(pcc_thunk_t *) * m);
        }
        obj->m = m;
    }
    obj->p[obj->n++] = thunk;
}

static void pcc_thunk_array__revert(pcc_context_t *ctx, pcc_thunk_array_t *obj, size_t len) {
    while (obj->n > len) {
        obj->n--;
        pcc_thunk__destroy(ctx, obj->p[obj->n]);
    }
}

MARK_FUNC_AS_USED
static pcc_thunk_chunk_t *pcc_thunk_chunk__create(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const obj = (pcc_thunk_chunk_t *)pcc_memory_recycler__supply(ctx->auxil, &(ctx->thunk_chunk_recycler));
    pcc_value_table__initialize(ctx->auxil, &(obj->values));
    pcc_capture_table__initialize(ctx->auxil, &(obj->capts));
    pcc_thunk_array__initialize(ctx, &(obj->thunks));
    obj->pos = 0;
    return obj;
}

static void pcc_thunk_chunk__destroy(pcc_context_t *ctx, pcc_thunk_chunk_t *obj) {
    if (obj == NULL) return;
    pcc_value_table__finalize(ctx->auxil, &(obj->values));
    pcc_capture_table__finalize(ctx->auxil, &(obj->capts));
    pcc_thunk_array__finalize(ctx, &(obj->thunks));
    pcc_memory_recycler__recycle(ctx->auxil, &(ctx->thunk_chunk_recycler), obj);
}

static void pcc_rule_set__initialize(pcc_auxil_t auxil, pcc_rule_set_t *obj) {
    obj->m = 0;
    obj->n = 0;
    obj->p = NULL;
}

static void pcc_rule_set__finalize(pcc_auxil_t auxil, pcc_rule_set_t *obj) {
    PCC_FREE(auxil, obj->p);
}

static void pcc_rule_set__clear(pcc_auxil_t auxil, pcc_rule_set_t *obj) {
    obj->n = 0;
}

static size_t pcc_rule_set__index(pcc_auxil_t auxil, const pcc_rule_set_t *obj, pcc_rule_t rule) {
    size_t i;
    for (i = 0; i < obj->n; i++) {
        if (obj->p[i] == rule) return i;
    }
    return PCC_VOID_VALUE;
}

static pcc_bool_t pcc_rule_set__add(pcc_auxil_t auxil, pcc_rule_set_t *obj, pcc_rule_t rule) {
    const size_t i = pcc_rule_set__index(auxil, obj, rule);
    if (i != PCC_VOID_VALUE) return PCC_FALSE;
    if (obj->m <= obj->n) {
        const size_t n = obj->n + 1;
        size_t m = obj->m;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        obj->p = (pcc_rule_t *)PCC_REALLOC(auxil, obj->p, sizeof(pcc_rule_t) * m);
        obj->m = m;
    }
    obj->p[obj->n++] = rule;
    return PCC_TRUE;
}

static pcc_bool_t pcc_rule_set__remove(pcc_auxil_t auxil, pcc_rule_set_t *obj, pcc_rule_t rule) {
    const size_t i = pcc_rule_set__index(auxil, obj, rule);
    if (i == PCC_VOID_VALUE) return PCC_FALSE;
    memmove(obj->p + i, obj->p + (i + 1), sizeof(pcc_rule_t) * (obj->n - (i + 1)));
    return PCC_TRUE;
}

static void pcc_rule_set__copy(pcc_auxil_t auxil, pcc_rule_set_t *obj, const pcc_rule_set_t *src) {
    size_t i;
    if (obj == src) return;
    pcc_rule_set__clear(auxil, obj);
    for (i = 0; i < src->n; i++) {
        pcc_rule_set__add(auxil, obj, src->p[i]);
    }
}

static pcc_lr_head_t *pcc_lr_head__create(pcc_context_t *ctx, pcc_rule_t rule) {
    pcc_lr_head_t *const obj = (pcc_lr_head_t *)pcc_memory_recycler__supply(ctx->auxil, &(ctx->lr_head_recycler));
    obj->rule = rule;
    pcc_rule_set__initialize(ctx->auxil, &(obj->invol));
    pcc_rule_set__initialize(ctx->auxil, &(obj->eval));
    obj->hold = NULL;
    return obj;
}

static void pcc_lr_head__destroy(pcc_context_t *ctx, pcc_lr_head_t *obj) {
    if (obj == NULL) return;
    pcc_rule_set__finalize(ctx->auxil, &(obj->invol));
    pcc_rule_set__finalize(ctx->auxil, &(obj->eval));
    pcc_lr_head__destroy(ctx, obj->hold);
    pcc_memory_recycler__recycle(ctx->auxil, &(ctx->lr_head_recycler), obj);
}

static void pcc_lr_entry__destroy(pcc_context_t *ctx, pcc_lr_entry_t *lr);

static pcc_lr_answer_t *pcc_lr_answer__create(pcc_context_t *ctx, pcc_lr_answer_type_t type, size_t pos) {
    pcc_lr_answer_t *obj = (pcc_lr_answer_t *)pcc_memory_recycler__supply(ctx->auxil, &(ctx->lr_answer_recycler));
    obj->type = type;
    obj->pos = pos;
    obj->hold = NULL;
    switch (obj->type) {
    case PCC_LR_ANSWER_LR:
        obj->data.lr = NULL;
        break;
    case PCC_LR_ANSWER_CHUNK:
        obj->data.chunk = NULL;
        break;
    default: /* unknown */
        pcc_memory_recycler__recycle(ctx->auxil, &(ctx->lr_answer_recycler), obj);
        obj = NULL;
    }
    return obj;
}

static void pcc_lr_answer__destroy(pcc_context_t *ctx, pcc_lr_answer_t *obj) {
    while (obj != NULL) {
        pcc_lr_answer_t *const a = obj->hold;
        switch (obj->type) {
        case PCC_LR_ANSWER_LR:
            pcc_lr_entry__destroy(ctx, obj->data.lr);
            break;
        case PCC_LR_ANSWER_CHUNK:
            pcc_thunk_chunk__destroy(ctx, obj->data.chunk);
            break;
        default: /* unknown */
            break;
        }
        pcc_memory_recycler__recycle(ctx->auxil, &(ctx->lr_answer_recycler), obj);
        obj = a;
    }
}

static void pcc_lr_answer__set_chunk(pcc_context_t *ctx, pcc_lr_answer_t *obj, pcc_thunk_chunk_t *chunk) {
    pcc_lr_answer_t *const a = pcc_lr_answer__create(ctx, obj->type, obj->pos);
    switch (obj->type) {
    case PCC_LR_ANSWER_LR:
        a->data.lr = obj->data.lr;
        break;
    case PCC_LR_ANSWER_CHUNK:
        a->data.chunk = obj->data.chunk;
        break;
    default: /* unknown */
        break;
    }
    a->hold = obj->hold;
    obj->hold = a;
    obj->type = PCC_LR_ANSWER_CHUNK;
    obj->data.chunk = chunk;
}

static void pcc_lr_memo_map__initialize(pcc_context_t *ctx, pcc_lr_memo_map_t *obj) {
    obj->m = PCC_LR_MEMO_MAP_MIN_SIZE;
    obj->n = 0;
    obj->p = obj->a;
}

static void pcc_lr_memo_map__finalize(pcc_context_t *ctx, pcc_lr_memo_map_t *obj) {
    while (obj->n > 0) {
        obj->n--;
        pcc_lr_answer__destroy(ctx, obj->p[obj->n].answer);
    }
    if (obj->p != obj->a) PCC_FREE(ctx->auxil, obj->p);
}

static size_t pcc_lr_memo_map__index(pcc_context_t *ctx, pcc_lr_memo_map_t *obj, pcc_rule_t rule) {
    size_t i;
    for (i = 0; i < obj->n; i++) {
        if (obj->p[i].rule == rule) return i;
    }
    return PCC_VOID_VALUE;
}

static void pcc_lr_memo_map__put(pcc_context_t *ctx, pcc_lr_memo_map_t *obj, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    const size_t i = pcc_lr_memo_map__index(ctx, obj, rule);
    if (i != PCC_VOID_VALUE) {
        pcc_lr_answer__destroy(ctx, obj->p[i].answer);
        obj->p[i].answer = answer;
    }
    else {
        if (obj->m <= obj->n) {
            const size_t n = obj->n + 1;
            size_t m = obj->m;
            if (m == 0) m = PCC_LR_MEMO_MAP_MIN_SIZE << 1;
            while (m < n && m != 0) m <<= 1;
            if (m == 0) m = n;
            if (obj->p == obj->a) {
                size_t i;
                obj->p = (pcc_lr_memo_t *)PCC_MALLOC(ctx->auxil, sizeof(pcc_lr_memo_t) * m);
                for (i = 0; i < PCC_LR_MEMO_MAP_MIN_SIZE; i++) obj->p[i] = obj->a[i];
            }
            else {
                obj->p = (pcc_lr_memo_t *)PCC_REALLOC(ctx->auxil, obj->p, sizeof(pcc_lr_memo_t) * m);
            }
            obj->m = m;
        }
        obj->p[obj->n].rule = rule;
        obj->p[obj->n].answer = answer;
        obj->n++;
    }
}

static pcc_lr_answer_t *pcc_lr_memo_map__get(pcc_context_t *ctx, pcc_lr_memo_map_t *obj, pcc_rule_t rule) {
    const size_t i = pcc_lr_memo_map__index(ctx, obj, rule);
    return (i != PCC_VOID_VALUE) ? obj->p[i].answer : NULL;
}

static pcc_lr_table_entry_t *pcc_lr_table_entry__create(pcc_context_t *ctx) {
    pcc_lr_table_entry_t *const obj = (pcc_lr_table_entry_t *)pcc_memory_recycler__supply(ctx->auxil, &(ctx->lr_table_entry_recycler));
    obj->head = NULL;
    pcc_lr_memo_map__initialize(ctx, &(obj->memos));
    obj->hold_a = NULL;
    obj->hold_h = NULL;
    return obj;
}

static void pcc_lr_table_entry__destroy(pcc_context_t *ctx, pcc_lr_table_entry_t *obj) {
    if (obj == NULL) return;
    pcc_lr_memo_map__finalize(ctx, &(obj->memos));
    pcc_lr_answer__destroy(ctx, obj->hold_a);
    pcc_lr_head__destroy(ctx, obj->hold_h);
    pcc_memory_recycler__recycle(ctx->auxil, &(ctx->lr_table_entry_recycler), obj);
}

static void pcc_lr_table__initialize(pcc_context_t *ctx, pcc_lr_table_t *obj) {
    obj->o = 0;
    obj->m = 0;
    obj->n = 0;
    obj->p = NULL;
}

static void pcc_lr_table__finalize(pcc_context_t *ctx, pcc_lr_table_t *obj) {
    while (obj->n > obj->o) {
        obj->n--;
        pcc_lr_table_entry__destroy(ctx, obj->p[obj->n]);
    }
    PCC_FREE(ctx->auxil, obj->p);
}

static void pcc_lr_table__resize(pcc_context_t *ctx, pcc_lr_table_t *obj, size_t len) {
    size_t i;
    for (i = len; i < obj->n; i++) pcc_lr_table_entry__destroy(ctx, obj->p[i]);
    if (obj->m < len) {
        size_t m = obj->m;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        obj->p = (pcc_lr_table_entry_t **)PCC_REALLOC(ctx->auxil, obj->p, sizeof(pcc_lr_table_entry_t *) * m);
        obj->m = m;
    }
    for (i = obj->n; i < len; i++) obj->p[i] = NULL;
    obj->n = len;
}

static void pcc_lr_table__set_head(pcc_context_t *ctx, pcc_lr_table_t *obj, size_t index, pcc_lr_head_t *head) {
    index += obj->o;
    if (index >= obj->n) pcc_lr_table__resize(ctx, obj, index + 1);
    if (obj->p[index] == NULL) obj->p[index] = pcc_lr_table_entry__create(ctx);
    obj->p[index]->head = head;
}

static void pcc_lr_table__hold_head(pcc_context_t *ctx, pcc_lr_table_t *obj, size_t index, pcc_lr_head_t *head) {
    index += obj->o;
    if (index >= obj->n) pcc_lr_table__resize(ctx, obj, index + 1);
    if (obj->p[index] == NULL) obj->p[index] = pcc_lr_table_entry__create(ctx);
    head->hold = obj->p[index]->hold_h;
    obj->p[index]->hold_h = head;
}

static void pcc_lr_table__set_answer(pcc_context_t *ctx, pcc_lr_table_t *obj, size_t index, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    index += obj->o;
    if (index >= obj->n) pcc_lr_table__resize(ctx, obj, index + 1);
    if (obj->p[index] == NULL) obj->p[index] = pcc_lr_table_entry__create(ctx);
    pcc_lr_memo_map__put(ctx, &(obj->p[index]->memos), rule, answer);
}

static void pcc_lr_table__hold_answer(pcc_context_t *ctx, pcc_lr_table_t *obj, size_t index, pcc_lr_answer_t *answer) {
    index += obj->o;
    if (index >= obj->n) pcc_lr_table__resize(ctx, obj, index + 1);
    if (obj->p[index] == NULL) obj->p[index] = pcc_lr_table_entry__create(ctx);
    answer->hold = obj->p[index]->hold_a;
    obj->p[index]->hold_a = answer;
}

static pcc_lr_head_t *pcc_lr_table__get_head(pcc_context_t *ctx, pcc_lr_table_t *obj, size_t index) {
    index += obj->o;
    if (index >= obj->n || obj->p[index] == NULL) return NULL;
    return obj->p[index]->head;
}

static pcc_lr_answer_t *pcc_lr_table__get_answer(pcc_context_t *ctx, pcc_lr_table_t *obj, size_t index, pcc_rule_t rule) {
    index += obj->o;
    if (index >= obj->n || obj->p[index] == NULL) return NULL;
    return pcc_lr_memo_map__get(ctx, &(obj->p[index]->memos), rule);
}

static void pcc_lr_table__shift(pcc_context_t *ctx, pcc_lr_table_t *obj, size_t count) {
    size_t i;
    if (count > obj->n - obj->o) count = obj->n - obj->o;
    for (i = 0; i < count; i++) pcc_lr_table_entry__destroy(ctx, obj->p[obj->o++]);
    if (obj->o > (obj->m >> 1)) {
        memmove(obj->p, obj->p + obj->o, sizeof(pcc_lr_table_entry_t *) * (obj->n - obj->o));
        obj->n -= obj->o;
        obj->o = 0;
    }
}

static pcc_lr_entry_t *pcc_lr_entry__create(pcc_context_t *ctx, pcc_rule_t rule) {
    pcc_lr_entry_t *const lr = (pcc_lr_entry_t *)pcc_memory_recycler__supply(ctx->auxil, &(ctx->lr_entry_recycler));
    lr->rule = rule;
    lr->seed = NULL;
    lr->head = NULL;
    return lr;
}

static void pcc_lr_entry__destroy(pcc_context_t *ctx, pcc_lr_entry_t *lr) {
    pcc_memory_recycler__recycle(ctx->auxil, &(ctx->lr_entry_recycler), lr);
}

static void pcc_lr_stack__initialize(pcc_auxil_t auxil, pcc_lr_stack_t *obj) {
    obj->m = 0;
    obj->n = 0;
    obj->p = NULL;
}

static void pcc_lr_stack__finalize(pcc_auxil_t auxil, pcc_lr_stack_t *obj) {
    PCC_FREE(auxil, obj->p);
}

static void pcc_lr_stack__push(pcc_auxil_t auxil, pcc_lr_stack_t *obj, pcc_lr_entry_t *lr) {
    if (obj->m <= obj->n) {
        const size_t n = obj->n + 1;
        size_t m = obj->m;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        obj->p = (pcc_lr_entry_t **)PCC_REALLOC(auxil, obj->p, sizeof(pcc_lr_entry_t *) * m);
        obj->m = m;
    }
    obj->p[obj->n++] = lr;
}

static pcc_lr_entry_t *pcc_lr_stack__pop(pcc_auxil_t auxil, pcc_lr_stack_t *obj) {
    return obj->p[--obj->n];
}

static pcc_context_t *pcc_context__create(pcc_auxil_t auxil) {
    pcc_context_t *const ctx = (pcc_context_t *)PCC_MALLOC(auxil, sizeof(pcc_context_t));
    ctx->pos = 0;
    ctx->cur = 0;
    ctx->level = 0;
    pcc_char_array__initialize(auxil, &(ctx->buffer));
    pcc_lr_table__initialize(ctx, &(ctx->lrtable));
    pcc_lr_stack__initialize(auxil, &(ctx->lrstack));
    pcc_thunk_array__initialize(ctx, &(ctx->thunks));
    pcc_capture__initialize(ctx->auxil, &(ctx->capt0));
    pcc_memory_recycler__initialize(auxil, &(ctx->thunk_recycler), sizeof(pcc_thunk_t));
    pcc_memory_recycler__initialize(auxil, &(ctx->thunk_chunk_recycler), sizeof(pcc_thunk_chunk_t));
    pcc_memory_recycler__initialize(auxil, &(ctx->lr_head_recycler), sizeof(pcc_lr_head_t));
    pcc_memory_recycler__initialize(auxil, &(ctx->lr_answer_recycler), sizeof(pcc_lr_answer_t));
    pcc_memory_recycler__initialize(auxil, &(ctx->lr_table_entry_recycler), sizeof(pcc_lr_table_entry_t));
    pcc_memory_recycler__initialize(auxil, &(ctx->lr_entry_recycler), sizeof(pcc_lr_entry_t));
    ctx->auxil = auxil;
    return ctx;
}

static void pcc_context__destroy(pcc_context_t *ctx) {
    if (ctx == NULL) return;
    pcc_char_array__finalize(ctx->auxil, &(ctx->buffer));
    pcc_lr_table__finalize(ctx, &(ctx->lrtable));
    pcc_lr_stack__finalize(ctx->auxil, &(ctx->lrstack));
    pcc_thunk_array__finalize(ctx, &(ctx->thunks));
    pcc_capture__finalize(ctx->auxil, &(ctx->capt0));
    pcc_memory_recycler__finalize(ctx->auxil, &(ctx->thunk_recycler));
    pcc_memory_recycler__finalize(ctx->auxil, &(ctx->thunk_chunk_recycler));
    pcc_memory_recycler__finalize(ctx->auxil, &(ctx->lr_head_recycler));
    pcc_memory_recycler__finalize(ctx->auxil, &(ctx->lr_answer_recycler));
    pcc_memory_recycler__finalize(ctx->auxil, &(ctx->lr_table_entry_recycler));
    pcc_memory_recycler__finalize(ctx->auxil, &(ctx->lr_entry_recycler));
    PCC_FREE(ctx->auxil, ctx);
}

static size_t pcc_refill_buffer(pcc_context_t *ctx, size_t num) {
    if (ctx->buffer.n >= ctx->cur + num) return ctx->buffer.n - ctx->cur;
    while (ctx->buffer.n < ctx->cur + num) {
        const int c = PCC_GETCHAR(ctx->auxil);
        if (c < 0) break;
        pcc_char_array__add(ctx->auxil, &(ctx->buffer), (char)c);
    }
    return ctx->buffer.n - ctx->cur;
}

MARK_FUNC_AS_USED
static void pcc_commit_buffer(pcc_context_t *ctx) {
    memmove(ctx->buffer.p, ctx->buffer.p + ctx->cur, ctx->buffer.n - ctx->cur);
    ctx->buffer.n -= ctx->cur;
    ctx->pos += ctx->cur;
    pcc_lr_table__shift(ctx, &(ctx->lrtable), ctx->cur);
    ctx->cur = 0;
}

MARK_FUNC_AS_USED
static const char *pcc_get_capture_string(pcc_context_t *ctx, const pcc_capture_t *capt) {
    if (capt->string.n == 0) {
        const size_t n = capt->range.end - capt->range.start;
        pcc_capture_t *const p = (pcc_capture_t *)capt;
        pcc_char_array__resize(ctx->auxil, &(p->string), n + 1);
        if (n > 0) memcpy(p->string.p, ctx->buffer.p + capt->range.start, n);
        p->string.p[n] = '\0';
    }
    return capt->string.p;
}

static size_t pcc_get_char_as_utf32(pcc_context_t *ctx, int *out) { /* with checking UTF-8 validity */
    int c, u;
    size_t n, i;
    if (pcc_refill_buffer(ctx, 1) < 1) return 0;
    c = (int)(unsigned char)ctx->buffer.p[ctx->cur];
    n = (c < 0x80) ? 1 :
        ((c & 0xe0) == 0xc0) ? 2 :
        ((c & 0xf0) == 0xe0) ? 3 :
        ((c & 0xf8) == 0xf0) ? 4 :
        ((c & 0xfc) == 0xf8) ? 5 :
        ((c & 0xfe) == 0xfc) ? 6 : 0;
    if (n < 1) return 0;
    if (pcc_refill_buffer(ctx, n) < n) return 0;
    u = (n <= 1) ? c : (c & ((1 << (7 - n)) - 1));
    for (i = 1; i < n; i++) {
        const int d = (int)(unsigned char)ctx->buffer.p[ctx->cur + i];
        if ((d & 0xc0) != 0x80) return 0; /* not a continuation byte */
        u = (u << 6) | (d & 0x3f);
    }
    if (
        (n == 2 && u < 0x00000080) ||
        (n == 3 && u < 0x00000800) ||
        (n == 4 && u < 0x00010000) ||
        (n == 5 && u < 0x00200000) ||
        (n == 6 && u < 0x04000000)
    ) return 0; /* invalidly encoded */
    if (out) *out = u;
    return n;
}

MARK_FUNC_AS_USED
static pcc_bool_t pcc_apply_rule(pcc_context_t *ctx, pcc_rule_t rule, pcc_thunk_array_t *thunks, pcc_value_t *value) {
    static pcc_value_t null;
    pcc_thunk_chunk_t *c = NULL;
    const size_t p = ctx->pos + ctx->cur;
    pcc_bool_t b = PCC_TRUE;
    pcc_lr_answer_t *a = pcc_lr_table__get_answer(ctx, &(ctx->lrtable), p, rule);
    pcc_lr_head_t *h = pcc_lr_table__get_head(ctx, &(ctx->lrtable), p);
    if (h != NULL) {
        if (a == NULL && rule != h->rule && pcc_rule_set__index(ctx->auxil, &(h->invol), rule) == PCC_VOID_VALUE) {
            b = PCC_FALSE;
            c = NULL;
        }
        else if (pcc_rule_set__remove(ctx->auxil, &(h->eval), rule)) {
            b = PCC_FALSE;
            c = rule(ctx);
            a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_CHUNK, ctx->pos + ctx->cur);
            a->data.chunk = c;
            pcc_lr_table__hold_answer(ctx, &(ctx->lrtable), p, a);
        }
    }
    if (b) {
        if (a != NULL) {
            ctx->cur = a->pos - ctx->pos;
            switch (a->type) {
            case PCC_LR_ANSWER_LR:
                if (a->data.lr->head == NULL) {
                    a->data.lr->head = pcc_lr_head__create(ctx, rule);
                    pcc_lr_table__hold_head(ctx, &(ctx->lrtable), p, a->data.lr->head);
                }
                {
                    size_t i = ctx->lrstack.n;
                    while (i > 0) {
                        i--;
                        if (ctx->lrstack.p[i]->head == a->data.lr->head) break;
                        ctx->lrstack.p[i]->head = a->data.lr->head;
                        pcc_rule_set__add(ctx->auxil, &(a->data.lr->head->invol), ctx->lrstack.p[i]->rule);
                    }
                }
                c = a->data.lr->seed;
                break;
            case PCC_LR_ANSWER_CHUNK:
                c = a->data.chunk;
                break;
            default: /* unknown */
                break;
            }
        }
        else {
            pcc_lr_entry_t *const e = pcc_lr_entry__create(ctx, rule);
            pcc_lr_stack__push(ctx->auxil, &(ctx->lrstack), e);
            a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_LR, p);
            a->data.lr = e;
            pcc_lr_table__set_answer(ctx, &(ctx->lrtable), p, rule, a);
            c = rule(ctx);
            pcc_lr_stack__pop(ctx->auxil, &(ctx->lrstack));
            a->pos = ctx->pos + ctx->cur;
            if (e->head == NULL) {
                pcc_lr_answer__set_chunk(ctx, a, c);
            }
            else {
                e->seed = c;
                h = a->data.lr->head;
                if (h->rule != rule) {
                    c = a->data.lr->seed;
                    a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_CHUNK, ctx->pos + ctx->cur);
                    a->data.chunk = c;
                    pcc_lr_table__hold_answer(ctx, &(ctx->lrtable), p, a);
                }
                else {
                    pcc_lr_answer__set_chunk(ctx, a, a->data.lr->seed);
                    if (a->data.chunk == NULL) {
                        c = NULL;
                    }
                    else {
                        pcc_lr_table__set_head(ctx, &(ctx->lrtable), p, h);
                        for (;;) {
                            ctx->cur = p - ctx->pos;
                            pcc_rule_set__copy(ctx->auxil, &(h->eval), &(h->invol));
                            c = rule(ctx);
                            if (c == NULL || ctx->pos + ctx->cur <= a->pos) break;
                            pcc_lr_answer__set_chunk(ctx, a, c);
                            a->pos = ctx->pos + ctx->cur;
                        }
                        pcc_thunk_chunk__destroy(ctx, c);
                        pcc_lr_table__set_head(ctx, &(ctx->lrtable), p, NULL);
                        ctx->cur = a->pos - ctx->pos;
                        c = a->data.chunk;
                    }
                }
            }
        }
    }
    if (c == NULL) return PCC_FALSE;
    if (value == NULL) value = &null;
    memset(value, 0, sizeof(pcc_value_t)); /* in case */
    pcc_thunk_array__add(ctx, thunks, pcc_thunk__create_node(ctx, &(c->thunks), value));
    return PCC_TRUE;
}

MARK_FUNC_AS_USED
static void pcc_do_action(pcc_context_t *ctx, const pcc_thunk_array_t *thunks, pcc_value_t *value) {
    size_t i;
    for (i = 0; i < thunks->n; i++) {
        pcc_thunk_t *const thunk = thunks->p[i];
        switch (thunk->type) {
        case PCC_THUNK_LEAF:
            thunk->data.leaf.action(ctx, thunk, value);
            break;
        case PCC_THUNK_NODE:
            pcc_do_action(ctx, thunk->data.node.thunks, thunk->data.node.value);
            break;
        default: /* unknown */
            break;
        }
    }
}

MARK_FUNC_AS_USED
static pcc_auxil_t pcc_ref_auxil_(pcc_context_t *ctx) {
    return ctx->auxil;
}

MARK_FUNC_AS_USED
static const char *pcc_ref_capture_0_(pcc_context_t *ctx) {
    return pcc_get_capture_string(ctx, &(ctx->capt0));
}

MARK_FUNC_AS_USED
static size_t pcc_ref_capture_0s_(pcc_context_t *ctx) {
    return ctx->pos + ctx->capt0.range.start;
}

MARK_FUNC_AS_USED
static size_t pcc_ref_capture_0e_(pcc_context_t *ctx) {
    return ctx->pos + ctx->capt0.range.end;
}

MARK_FUNC_AS_USED
static const char *pcc_ref_capture_(pcc_context_t *ctx, pcc_thunk_chunk_t *in, size_t index) {
    return pcc_get_capture_string(ctx, &(in->capts.p[index]));
}

MARK_FUNC_AS_USED
static size_t pcc_ref_capture_s_(pcc_context_t *ctx, pcc_thunk_chunk_t *in, size_t index) {
    return ctx->pos + in->capts.p[index].range.start;
}

MARK_FUNC_AS_USED
static size_t pcc_ref_capture_e_(pcc_context_t *ctx, pcc_thunk_chunk_t *in, size_t index) {
    return ctx->pos + in->capts.p[index].range.end;
}

MARK_FUNC_AS_USED
static const char *pcc_ref_leaf_capture_0_(pcc_context_t *ctx, pcc_thunk_t *in) {
    return pcc_get_capture_string(ctx, &(in->data.leaf.capt0));
}

MARK_FUNC_AS_USED
static size_t pcc_ref_leaf_capture_0s_(pcc_context_t *ctx, pcc_thunk_t *in) {
    return ctx->pos + in->data.leaf.capt0.range.start;
}

MARK_FUNC_AS_USED
static size_t pcc_ref_leaf_capture_0e_(pcc_context_t *ctx, pcc_thunk_t *in) {
    return ctx->pos + in->data.leaf.capt0.range.end;
}

MARK_FUNC_AS_USED
static const char *pcc_ref_leaf_capture_(pcc_context_t *ctx, pcc_thunk_t *in, size_t index) {
    return pcc_get_capture_string(ctx, in->data.leaf.capts.p[index]);
}

MARK_FUNC_AS_USED
static size_t pcc_ref_leaf_capture_s_(pcc_context_t *ctx, pcc_thunk_t *in, size_t index) {
    return ctx->pos + in->data.leaf.capts.p[index]->range.start;
}

MARK_FUNC_AS_USED
static size_t pcc_ref_leaf_capture_e_(pcc_context_t *ctx, pcc_thunk_t *in, size_t index) {
    return ctx->pos + in->data.leaf.capts.p[index]->range.end;
}

MARK_FUNC_AS_USED
static pcc_value_t *pcc_ref_leaf_variable_(pcc_context_t *ctx, pcc_thunk_t *in, size_t index) {
    return in->data.leaf.values.p[index];
}

static void pcc_action_Xvalue_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_tune_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Kheader_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_header_append(auxil, pcc_capture__1, 'K');
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Iheader_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_header_append(auxil, pcc_capture__1, 'I');
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Iheader_1(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__2 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 1)
    if (strlen(pcc_capture__2) == 1) auxil->tunes[auxil->count -1]->lbc = (pcc_capture__2)[0]; else if (!strcmp(pcc_capture__2, "<none>")) auxil->tunes[auxil->count - 1]->lbc = '\0';
#undef pcc_capture__2e
#undef pcc_capture__2s
#undef pcc_capture__2
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_HeaderKey_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    pcc_action_out = (pcc_capture__0)[0];
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Oheader_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define key (*pcc_ref_leaf_variable_(pcc_ctx, pcc_in, 0))
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_header_append(auxil, pcc_capture__1, key);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef key
#undef pcc_action_out
#undef auxil
}

static void pcc_action_KeySig_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_change_append(auxil, pcc_capture__1);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Unit_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_change_append(auxil, pcc_capture__1);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_TimeSig_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_change_append(auxil, pcc_capture__1);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Tempo_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_change_append(auxil, pcc_capture__1);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Vvalue_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_voice_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_ChordPunct_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_chordpunct_set(auxil, pcc_capture__1);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_NotePunct_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_notepunct_set(auxil, pcc_capture__1);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_MidiInstruction_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_instruction_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Lyrics_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_lyrics_append(auxil, pcc_capture__1);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Tie_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_tie_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Grace_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_grace_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Grace_1(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
#define pcc_capture__2 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 1)
    abc_grace_append(auxil, pcc_capture__2);
#undef pcc_capture__2e
#undef pcc_capture__2s
#undef pcc_capture__2
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Chord_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_chord_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Chord_1(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
#define pcc_capture__2 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 1)
    abc_chord_append(auxil, pcc_capture__2);
#undef pcc_capture__2e
#undef pcc_capture__2s
#undef pcc_capture__2
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action___0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_space_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Decoration_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_deco_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_ExDecoration_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_deco_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Nuplet_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define p (*pcc_ref_leaf_variable_(pcc_ctx, pcc_in, 0))
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
    abc_nuplet_append(auxil, p, 0, 0);
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef p
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Nuplet_1(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define p (*pcc_ref_leaf_variable_(pcc_ctx, pcc_in, 0))
#define q (*pcc_ref_leaf_variable_(pcc_ctx, pcc_in, 1))
#define r (*pcc_ref_leaf_variable_(pcc_ctx, pcc_in, 2))
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
    abc_nuplet_append(auxil, p, q, r);
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef r
#undef q
#undef p
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Nuplet_2(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define p (*pcc_ref_leaf_variable_(pcc_ctx, pcc_in, 0))
#define q (*pcc_ref_leaf_variable_(pcc_ctx, pcc_in, 1))
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
    abc_nuplet_append(auxil, p, q, 0);
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef q
#undef p
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Nuplet_3(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define p (*pcc_ref_leaf_variable_(pcc_ctx, pcc_in, 0))
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
    abc_nuplet_append(auxil, p, 0, 0);
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef p
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Digits_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    pcc_action_out = atoi(pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Gchord_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_gchord_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_SlurStart_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_slur_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_SlurEnd_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_slur_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_SimpleAlter_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_alt_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Alternative_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_alt_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Bar_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_bar_append(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_ChordDuration_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_duration_chord_num_set(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_ChordDuration_1(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
#define pcc_capture__2 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 1)
    abc_duration_chord_den_set(auxil, pcc_capture__2);
#undef pcc_capture__2e
#undef pcc_capture__2s
#undef pcc_capture__2
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_ChordDuration_2(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__3 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 2)
#define pcc_capture__3s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 2)
#define pcc_capture__3e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 2)
    abc_duration_chord_num_set(auxil, pcc_capture__0);
#undef pcc_capture__3e
#undef pcc_capture__3s
#undef pcc_capture__3
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_ChordDuration_3(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__4 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 3)
#define pcc_capture__4s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 3)
#define pcc_capture__4e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 3)
    abc_duration_chord_den_set(auxil, pcc_capture__0);
#undef pcc_capture__4e
#undef pcc_capture__4s
#undef pcc_capture__4
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_NoteDuration_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_duration_num_set(auxil, pcc_capture__0);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_NoteDuration_1(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
#define pcc_capture__2 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 1)
    abc_duration_den_set(auxil, pcc_capture__2);
#undef pcc_capture__2e
#undef pcc_capture__2s
#undef pcc_capture__2
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_NoteDuration_2(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__3 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 2)
#define pcc_capture__3s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 2)
#define pcc_capture__3e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 2)
    abc_duration_num_set(auxil, pcc_capture__0);
#undef pcc_capture__3e
#undef pcc_capture__3s
#undef pcc_capture__3
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_NoteDuration_3(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__4 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 3)
#define pcc_capture__4s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 3)
#define pcc_capture__4e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 3)
    abc_duration_den_set(auxil, pcc_capture__0);
#undef pcc_capture__4e
#undef pcc_capture__4s
#undef pcc_capture__4
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_Note_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    abc_note_append(auxil, pcc_capture__0, pcc_capture__0s);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_LineBreak_0(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__1 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 0)
#define pcc_capture__1e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 0)
    if ((pcc_capture__1)[0] == auxil->tunes[auxil->count -1]->lbc) abc_eol_append(auxil, pcc_capture__1);
#undef pcc_capture__1e
#undef pcc_capture__1s
#undef pcc_capture__1
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static void pcc_action_LineBreak_1(pcc_context_t *pcc_ctx, pcc_thunk_t *pcc_in, pcc_value_t *pcc_out) {
#define auxil pcc_ref_auxil_(pcc_ctx)
#define pcc_action_out (*pcc_out)
#define pcc_capture__0 pcc_ref_leaf_capture_0_(pcc_ctx, pcc_in)
#define pcc_capture__0s pcc_ref_leaf_capture_0s_(pcc_ctx, pcc_in)
#define pcc_capture__0e pcc_ref_leaf_capture_0e_(pcc_ctx, pcc_in)
#define pcc_capture__2 pcc_ref_leaf_capture_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2s pcc_ref_leaf_capture_s_(pcc_ctx, pcc_in, 1)
#define pcc_capture__2e pcc_ref_leaf_capture_e_(pcc_ctx, pcc_in, 1)
    if ((pcc_capture__2)[0] == auxil->tunes[auxil->count -1]->lbc) abc_eol_append(auxil, pcc_capture__2); else { auxil->buffer->index = pcc_capture__2s; gen_error(auxil); }
#undef pcc_capture__2e
#undef pcc_capture__2s
#undef pcc_capture__2
#undef pcc_capture__0e
#undef pcc_capture__0s
#undef pcc_capture__0
#undef pcc_action_out
#undef auxil
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TuneBook(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Ignored(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Ps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BeginPs(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EndPs(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Text(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BeginText(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EndText(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Svg(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BeginSvg(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EndSvg(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Tune(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Words(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Header(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Xheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Xvalue(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Kheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Iheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_HeaderKey(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Oheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VoiceDef(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Score(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FragmentLine(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Fragment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InlineChange(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Change(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KeySig(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Unit(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TimeSig(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Part(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Tempo(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Special(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Comment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Vheader(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Vvalue(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ChordPunct(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NotePunct(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NoteConstruct(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MidiInstruction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Lyrics(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Tie(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Grace(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Chord(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule__(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Decoration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExDecoration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Nuplet(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Digits(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Gchord(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SlurStart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SlurEnd(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SimpleAlter(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Alternative(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Bar(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ChordDuration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NoteDuration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Note(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EOL(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LineCont(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LineBreak(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EOF(pcc_context_t *ctx);

static pcc_thunk_chunk_t *pcc_evaluate_rule_TuneBook(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TuneBook", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Ignored, &(chunk->thunks), NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tune, &(chunk->thunks), NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TuneBook, &(chunk->thunks), NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOF, &(chunk->thunks), NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TuneBook", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TuneBook", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Ignored(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Ignored", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Ps, &(chunk->thunks), NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Text, &(chunk->thunks), NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Svg, &(chunk->thunks), NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &(chunk->thunks), NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Ignored", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Ignored", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Ps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Ps", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BeginPs, &(chunk->thunks), NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndPs, &(chunk->thunks), NULL)) goto L0002;
                ctx->cur = p;
                goto L0001;
            L0002:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndPs, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Ps", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Ps", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BeginPs(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BeginPs", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '%' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '%' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'g' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 'p' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.p + ctx->cur)[8] != 's'
    ) goto L0000;
    ctx->cur += 9;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
                ctx->cur = p;
                goto L0001;
            L0002:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BeginPs", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BeginPs", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EndPs(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EndPs", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '%' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '%' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'd' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'p' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 's'
    ) goto L0000;
    ctx->cur += 7;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EndPs", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EndPs", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Text(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Text", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BeginText, &(chunk->thunks), NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndText, &(chunk->thunks), NULL)) goto L0002;
                ctx->cur = p;
                goto L0001;
            L0002:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndText, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Text", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Text", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BeginText(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BeginText", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '%' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '%' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'g' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.p + ctx->cur)[8] != 'e' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.p + ctx->cur)[9] != 'x' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.p + ctx->cur)[10] != 't'
    ) goto L0000;
    ctx->cur += 11;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
                ctx->cur = p;
                goto L0001;
            L0002:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BeginText", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BeginText", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EndText(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EndText", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '%' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '%' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'd' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 't' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'e' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 'x' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.p + ctx->cur)[8] != 't'
    ) goto L0000;
    ctx->cur += 9;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EndText", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EndText", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Svg(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Svg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BeginSvg, &(chunk->thunks), NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndSvg, &(chunk->thunks), NULL)) goto L0002;
                ctx->cur = p;
                goto L0001;
            L0002:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndSvg, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Svg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Svg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BeginSvg(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BeginSvg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '%' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '%' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'g' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 's' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.p + ctx->cur)[8] != 'v' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.p + ctx->cur)[9] != 'g'
    ) goto L0000;
    ctx->cur += 10;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
                ctx->cur = p;
                goto L0001;
            L0002:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BeginSvg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BeginSvg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EndSvg(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EndSvg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '%' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '%' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'd' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 's' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'v' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 'g'
    ) goto L0000;
    ctx->cur += 8;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EndSvg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EndSvg", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Tune(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Tune", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Xheader, &(chunk->thunks), NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Header, &(chunk->thunks), NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Kheader, &(chunk->thunks), NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
    L0003:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &(chunk->thunks), NULL)) goto L0004;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0004;
            if (ctx->cur == p) break;
            continue;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Score, &(chunk->thunks), NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Words, &(chunk->thunks), NULL)) goto L0005;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.n;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0006;
                goto L0007;
            L0006:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            L0007:;
            }
            if (ctx->cur == p) break;
            continue;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Tune", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Tune", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Words(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Words", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'W' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    u == 0x000020 ||
                    u == 0x000009
                )) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0003;
                ctx->cur = p;
                goto L0002;
            L0003:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0002;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Words", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Words", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Header(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Header", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Oheader, &(chunk->thunks), NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &(chunk->thunks), NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Header", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Header", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Xheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Xheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'X' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    u == 0x000020 ||
                    u == 0x000009
                )) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Xvalue, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Xheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Xheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Xvalue(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Xvalue", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                (u >= 0x000031 && u <= 0x000039)
            )) goto L0000;
            ctx->cur += n;
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Xvalue_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Xvalue", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Xvalue", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Kheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Kheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'K' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    u == 0x000020 ||
                    u == 0x000009
                )) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0003;
                    ctx->cur = p;
                    goto L0002;
                L0003:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Kheader_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Kheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Kheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Iheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Iheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 2);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'I' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0002;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0003;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0003;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p = ctx->cur;
                if (
                    pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'l' ||
                    pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'i' ||
                    pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'n' ||
                    pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'e' ||
                    pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'b' ||
                    pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'r' ||
                    pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'e' ||
                    pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 'a' ||
                    pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.p + ctx->cur)[8] != 'k'
                ) goto L0004;
                ctx->cur += 9;
                ctx->cur = p;
                goto L0002;
            L0004:;
                ctx->cur = p;
            }
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        const size_t p = ctx->cur;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0006;
                        ctx->cur = p;
                        goto L0005;
                    L0006:;
                        ctx->cur = p;
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0005;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0005:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
            }
            q = ctx->cur;
            chunk->capts.p[0].range.start = p;
            chunk->capts.p[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Iheader_0, 0, 2);
            thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'I' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0007;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0008;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0008;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0008:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'l' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'i' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'n' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'e' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'b' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'r' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'e' ||
            pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 'a' ||
            pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.p + ctx->cur)[8] != 'k'
        ) goto L0007;
        ctx->cur += 9;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0009;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0009;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0009:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.n;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        const size_t p = ctx->cur;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0011;
                        ctx->cur = p;
                        goto L0010;
                    L0011:;
                        ctx->cur = p;
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0010;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0010:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                    goto L0007;
                }
            }
            q = ctx->cur;
            chunk->capts.p[1].range.start = p;
            chunk->capts.p[1].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[1].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Iheader_1, 0, 2);
            thunk->data.leaf.capts.p[1] = &(chunk->capts.p[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Iheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Iheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_HeaderKey(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "HeaderKey", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                u == 0x000041 ||
                u == 0x000042 ||
                u == 0x000043 ||
                u == 0x000044 ||
                u == 0x000046 ||
                u == 0x000047 ||
                u == 0x000048 ||
                u == 0x00004c ||
                u == 0x00004d ||
                u == 0x00004e ||
                u == 0x00004f ||
                u == 0x000050 ||
                u == 0x000051 ||
                u == 0x000052 ||
                u == 0x000053 ||
                u == 0x000054 ||
                u == 0x000055 ||
                u == 0x000057 ||
                u == 0x00005a
            )) goto L0000;
            ctx->cur += n;
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_HeaderKey_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "HeaderKey", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "HeaderKey", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Oheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Oheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    pcc_value_table__resize(ctx->auxil, &(chunk->values), 1);
    pcc_value_table__clear(ctx->auxil, &(chunk->values));
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Iheader, &(chunk->thunks), NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_HeaderKey, &(chunk->thunks), &(chunk->values.p[0]))) goto L0003;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != ':'
        ) goto L0003;
        ctx->cur++;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0004;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0004;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        const size_t p = ctx->cur;
                        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0006;
                        ctx->cur = p;
                        goto L0005;
                    L0006:;
                        ctx->cur = p;
                    }
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0005;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0005:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
            }
            q = ctx->cur;
            chunk->capts.p[0].range.start = p;
            chunk->capts.p[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Oheader_0, 1, 1);
            thunk->data.leaf.values.p[0] = &(chunk->values.p[0]);
            thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VoiceDef, &(chunk->thunks), NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Oheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Oheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VoiceDef(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "VoiceDef", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'V' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.n;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
                ctx->cur = p;
                goto L0001;
            L0002:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
            goto L0000;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "VoiceDef", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "VoiceDef", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Score(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Score", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Vheader, &(chunk->thunks), NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FragmentLine, &(chunk->thunks), NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0002;
            }
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Score, &(chunk->thunks), NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FragmentLine, &(chunk->thunks), NULL)) goto L0006;
                if (ctx->cur == p) break;
                continue;
            L0006:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0005;
            }
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Score", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Score", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FragmentLine(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FragmentLine", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '%' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '%'
        ) goto L0002;
        ctx->cur += 2;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MidiInstruction, &(chunk->thunks), NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0004;
            goto L0003;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOF, &(chunk->thunks), NULL)) goto L0005;
            goto L0003;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            goto L0002;
        L0003:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &(chunk->thunks), NULL)) goto L0006;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0008;
            goto L0007;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOF, &(chunk->thunks), NULL)) goto L0009;
            goto L0007;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            goto L0006;
        L0007:;
        }
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Change, &(chunk->thunks), NULL)) goto L0010;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0012;
            goto L0011;
        L0012:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOF, &(chunk->thunks), NULL)) goto L0013;
            goto L0011;
        L0013:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            goto L0010;
        L0011:;
        }
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'w' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0014;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Lyrics, &(chunk->thunks), NULL)) goto L0015;
                if (ctx->cur == p) break;
                continue;
            L0015:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0017;
            goto L0016;
        L0017:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOF, &(chunk->thunks), NULL)) goto L0018;
            goto L0016;
        L0018:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            goto L0014;
        L0016:;
        }
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Fragment, &(chunk->thunks), NULL)) goto L0020;
                if (ctx->cur == p) break;
                continue;
            L0020:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0019;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.n;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.n;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LineCont, &(chunk->thunks), NULL)) goto L0024;
                    goto L0025;
                L0024:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                L0025:;
                }
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.n;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &(chunk->thunks), NULL)) goto L0026;
                    goto L0027;
                L0026:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                L0027:;
                }
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0023;
                goto L0022;
            L0023:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LineBreak, &(chunk->thunks), NULL)) goto L0028;
                goto L0022;
            L0028:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                goto L0021;
            L0022:;
            }
            goto L0029;
        L0021:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        L0029:;
        }
        goto L0001;
    L0019:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FragmentLine", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FragmentLine", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Fragment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Fragment", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &(chunk->thunks), NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != 'y'
        ) goto L0003;
        ctx->cur++;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InlineChange, &(chunk->thunks), NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NotePunct, &(chunk->thunks), NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &(chunk->thunks), NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '\"'
        ) goto L0007;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Gchord, &(chunk->thunks), NULL)) goto L0007;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '\"'
        ) goto L0007;
        ctx->cur++;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Decoration, &(chunk->thunks), NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '!'
        ) goto L0009;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExDecoration, &(chunk->thunks), NULL)) goto L0009;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '!'
        ) goto L0009;
        ctx->cur++;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ChordPunct, &(chunk->thunks), NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Chord, &(chunk->thunks), NULL)) goto L0011;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tie, &(chunk->thunks), NULL)) goto L0012;
            goto L0013;
        L0012:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        L0013:;
        }
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Grace, &(chunk->thunks), NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '('
        ) goto L0015;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Nuplet, &(chunk->thunks), NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SlurStart, &(chunk->thunks), NULL)) goto L0016;
        goto L0001;
    L0016:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SlurEnd, &(chunk->thunks), NULL)) goto L0017;
        goto L0001;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Bar, &(chunk->thunks), NULL)) goto L0018;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SimpleAlter, &(chunk->thunks), NULL)) goto L0018;
        goto L0001;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Bar, &(chunk->thunks), NULL)) goto L0019;
        goto L0001;
    L0019:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alternative, &(chunk->thunks), NULL)) goto L0020;
        goto L0001;
    L0020:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &(chunk->thunks), NULL)) goto L0021;
        goto L0001;
    L0021:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Fragment", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Fragment", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InlineChange(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InlineChange", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.p[ctx->cur] != '['
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Change, &(chunk->thunks), NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.p[ctx->cur] != ']'
    ) goto L0000;
    ctx->cur++;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InlineChange", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InlineChange", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Change(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Change", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KeySig, &(chunk->thunks), NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Unit, &(chunk->thunks), NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TimeSig, &(chunk->thunks), NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tempo, &(chunk->thunks), NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Part, &(chunk->thunks), NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Change", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Change", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KeySig(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KeySig", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'K' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0003;
                    ctx->cur = p;
                    goto L0002;
                L0003:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (
                        u == 0x00005d
                    ) goto L0002;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_KeySig_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KeySig", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KeySig", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Unit(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Unit", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'L' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0003;
                    ctx->cur = p;
                    goto L0002;
                L0003:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (
                        u == 0x00005d
                    ) goto L0002;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Unit_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Unit", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Unit", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TimeSig(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TimeSig", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'M' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0003;
                    ctx->cur = p;
                    goto L0002;
                L0003:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (
                        u == 0x00005d
                    ) goto L0002;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_TimeSig_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TimeSig", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TimeSig", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Part(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Part", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'P' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0003;
                    ctx->cur = p;
                    goto L0002;
                L0003:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (
                        u == 0x00005d
                    ) goto L0002;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Part", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Part", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Tempo(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Tempo", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'Q' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0000;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        u == 0x000020 ||
                        u == 0x000009
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0003;
                    ctx->cur = p;
                    goto L0002;
                L0003:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (
                        u == 0x00005d
                    ) goto L0002;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Tempo_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Tempo", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Tempo", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Special(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Special", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'M' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'I' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'D' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'I'
        ) goto L0002;
        ctx->cur += 4;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'b' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'e' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'g' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'i' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'n' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'p' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 's'
        ) goto L0003;
        ctx->cur += 7;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'e' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'n' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'd' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'p' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 's'
        ) goto L0004;
        ctx->cur += 5;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'b' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'e' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'g' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'i' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'n' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 't' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'e' ||
            pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 'x' ||
            pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.p + ctx->cur)[8] != 't'
        ) goto L0005;
        ctx->cur += 9;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'e' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'n' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'd' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 't' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'e' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'x' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 't'
        ) goto L0006;
        ctx->cur += 7;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'b' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'e' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'g' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'i' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'n' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 's' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.p + ctx->cur)[6] != 'v' ||
            pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.p + ctx->cur)[7] != 'g'
        ) goto L0007;
        ctx->cur += 8;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'e' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'n' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'd' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 's' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.p + ctx->cur)[4] != 'v' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.p + ctx->cur)[5] != 'g'
        ) goto L0008;
        ctx->cur += 6;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Special", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Special", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Comment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Comment", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '%'
        ) goto L0002;
        ctx->cur++;
        {
            const size_t p = ctx->cur;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != '%'
            ) goto L0003;
            ctx->cur++;
            ctx->cur = p;
            goto L0002;
        L0003:;
            ctx->cur = p;
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0005;
                    ctx->cur = p;
                    goto L0004;
                L0005:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0004;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '%' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '%'
        ) goto L0006;
        ctx->cur += 2;
        {
            const size_t p = ctx->cur;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Special, &(chunk->thunks), NULL)) goto L0007;
            ctx->cur = p;
            goto L0006;
        L0007:;
            ctx->cur = p;
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0009;
                    ctx->cur = p;
                    goto L0008;
                L0009:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0008;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0008:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Comment", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Comment", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Vheader(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Vheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'V' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    u == 0x000020 ||
                    u == 0x000009
                )) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Vvalue, &(chunk->thunks), NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Vheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Vheader", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Vvalue(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Vvalue", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
                    ctx->cur = p;
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Vvalue_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Vvalue", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Vvalue", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ChordPunct(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ChordPunct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Chord, &(chunk->thunks), NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tie, &(chunk->thunks), NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
    L0002:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &(chunk->thunks), NULL)) goto L0003;
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.n;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.p[ctx->cur] != '>'
                    ) goto L0006;
                    ctx->cur++;
                    goto L0005;
                L0006:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.p[ctx->cur] != '<'
                    ) goto L0007;
                    ctx->cur++;
                    goto L0005;
                L0007:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    goto L0004;
                L0005:;
                }
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &(chunk->thunks), NULL)) goto L0008;
            if (ctx->cur == p) break;
            continue;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Chord, &(chunk->thunks), NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tie, &(chunk->thunks), NULL)) goto L0009;
        goto L0010;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
    L0010:;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ChordPunct_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ChordPunct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ChordPunct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NotePunct(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NotePunct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &(chunk->thunks), NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &(chunk->thunks), NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.n;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.p[ctx->cur] != '>'
                    ) goto L0004;
                    ctx->cur++;
                    goto L0003;
                L0004:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.p[ctx->cur] != '<'
                    ) goto L0005;
                    ctx->cur++;
                    goto L0003;
                L0005:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    goto L0002;
                L0003:;
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &(chunk->thunks), NULL)) goto L0006;
            if (ctx->cur == p) break;
            continue;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &(chunk->thunks), NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_NotePunct_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NotePunct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NotePunct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NoteConstruct(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NoteConstruct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.n;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Decoration, &(chunk->thunks), NULL)) goto L0003;
                goto L0002;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                if (
                    pcc_refill_buffer(ctx, 1) < 1 ||
                    ctx->buffer.p[ctx->cur] != '!'
                ) goto L0004;
                ctx->cur++;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExDecoration, &(chunk->thunks), NULL)) goto L0004;
                if (
                    pcc_refill_buffer(ctx, 1) < 1 ||
                    ctx->buffer.p[ctx->cur] != '!'
                ) goto L0004;
                ctx->cur++;
                goto L0002;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                goto L0001;
            L0002:;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Note, &(chunk->thunks), NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteDuration, &(chunk->thunks), NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Tie, &(chunk->thunks), NULL)) goto L0007;
        goto L0008;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
    L0008:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NoteConstruct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NoteConstruct", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MidiInstruction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MidiInstruction", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != 'M' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != 'I' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.p + ctx->cur)[2] != 'D' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.p + ctx->cur)[3] != 'I'
        ) goto L0000;
        ctx->cur += 4;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                u == 0x000020 ||
                u == 0x000009
            )) goto L0000;
            ctx->cur += n;
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
                    ctx->cur = p;
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MidiInstruction_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MidiInstruction", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MidiInstruction", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Lyrics(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Lyrics", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    const size_t p = ctx->cur;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
                    ctx->cur = p;
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Lyrics_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Lyrics", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Lyrics", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Tie(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Tie", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '-'
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Tie_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Tie", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Tie", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Grace(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Grace", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 2);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            if (
                pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '{' ||
                pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '/'
            ) goto L0002;
            ctx->cur += 2;
            goto L0001;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != '{'
            ) goto L0003;
            ctx->cur++;
            goto L0001;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            goto L0000;
        L0001:;
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Grace_0, 0, 2);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.n;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &(chunk->thunks), NULL)) goto L0004;
            if (ctx->cur == p) break;
            continue;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
            goto L0000;
        }
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '}'
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.p[1].range.start = p;
        chunk->capts.p[1].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[1].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Grace_1, 0, 2);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capts.p[1] = &(chunk->capts.p[1]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Grace", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Grace", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Chord(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Chord", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 2);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '['
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Chord_0, 0, 2);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.n;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NoteConstruct, &(chunk->thunks), NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
            goto L0000;
        }
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != ']'
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.p[1].range.start = p;
        chunk->capts.p[1].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[1].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Chord_1, 0, 2);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capts.p[1] = &(chunk->capts.p[1]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ChordDuration, &(chunk->thunks), NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
    L0003:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Chord", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Chord", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule__(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "_", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                u == 0x000020 ||
                u == 0x000009
            )) goto L0000;
            ctx->cur += n;
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action___0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "_", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "_", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Decoration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Decoration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != '.'
            ) goto L0002;
            ctx->cur++;
            goto L0001;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != '~'
            ) goto L0003;
            ctx->cur++;
            goto L0001;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'H'
            ) goto L0004;
            ctx->cur++;
            goto L0001;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'L'
            ) goto L0005;
            ctx->cur++;
            goto L0001;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'M'
            ) goto L0006;
            ctx->cur++;
            goto L0001;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'O'
            ) goto L0007;
            ctx->cur++;
            goto L0001;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'P'
            ) goto L0008;
            ctx->cur++;
            goto L0001;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'S'
            ) goto L0009;
            ctx->cur++;
            goto L0001;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'T'
            ) goto L0010;
            ctx->cur++;
            goto L0001;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'u'
            ) goto L0011;
            ctx->cur++;
            goto L0001;
        L0011:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != 'v'
            ) goto L0012;
            ctx->cur++;
            goto L0001;
        L0012:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            goto L0000;
        L0001:;
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Decoration_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Decoration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Decoration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExDecoration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExDecoration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (
                        u == 0x000021
                    ) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ExDecoration_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExDecoration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExDecoration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Nuplet(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Nuplet", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_value_table__resize(ctx->auxil, &(chunk->values), 3);
    pcc_value_table__clear(ctx->auxil, &(chunk->values));
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &(chunk->thunks), &(chunk->values.p[0]))) goto L0002;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != ':' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != ':'
        ) goto L0002;
        ctx->cur += 2;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Nuplet_0, 3, 0);
            thunk->data.leaf.values.p[0] = &(chunk->values.p[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &(chunk->thunks), &(chunk->values.p[0]))) goto L0003;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != ':'
        ) goto L0003;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &(chunk->thunks), &(chunk->values.p[1]))) goto L0003;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != ':'
        ) goto L0003;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &(chunk->thunks), &(chunk->values.p[2]))) goto L0003;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Nuplet_1, 3, 0);
            thunk->data.leaf.values.p[0] = &(chunk->values.p[0]);
            thunk->data.leaf.values.p[1] = &(chunk->values.p[1]);
            thunk->data.leaf.values.p[2] = &(chunk->values.p[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &(chunk->thunks), &(chunk->values.p[0]))) goto L0004;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != ':'
        ) goto L0004;
        ctx->cur++;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &(chunk->thunks), &(chunk->values.p[1]))) goto L0004;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Nuplet_2, 3, 0);
            thunk->data.leaf.values.p[0] = &(chunk->values.p[0]);
            thunk->data.leaf.values.p[1] = &(chunk->values.p[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Digits, &(chunk->thunks), &(chunk->values.p[0]))) goto L0005;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Nuplet_3, 3, 0);
            thunk->data.leaf.values.p[0] = &(chunk->values.p[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Nuplet", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Nuplet", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Digits(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Digits", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Digits_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Digits", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Digits", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Gchord(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Gchord", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (
                        u == 0x000022
                    ) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Gchord_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Gchord", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SlurStart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SlurStart", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '('
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_SlurStart_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SlurStart", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SlurStart", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SlurEnd(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SlurEnd", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != ')'
        ) goto L0000;
        ctx->cur++;
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_SlurEnd_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SlurEnd", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SlurEnd", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SimpleAlter(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SimpleAlter", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        (u >= 0x000031 && u <= 0x000039)
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (!(
                        u == 0x00002d ||
                        u == 0x00002c
                    )) goto L0002;
                    ctx->cur += n;
                }
                {
                    const size_t p0 = ctx->cur;
                    const size_t n0 = chunk->thunks.n;
                    int i;
                    for (i = 0;; i++) {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.n;
                        {
                            int u;
                            const size_t n = pcc_get_char_as_utf32(ctx, &u);
                            if (n == 0) goto L0003;
                            if (!(
                                (u >= 0x000031 && u <= 0x000039)
                            )) goto L0003;
                            ctx->cur += n;
                        }
                        if (ctx->cur == p) break;
                        continue;
                    L0003:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                        break;
                    }
                    if (i < 1) {
                        ctx->cur = p0;
                        pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                        goto L0002;
                    }
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_SimpleAlter_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SimpleAlter", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SimpleAlter", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Alternative(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Alternative", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '['
        ) goto L0000;
        ctx->cur++;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        (u >= 0x000031 && u <= 0x000039)
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0002;
                    if (!(
                        u == 0x00002d ||
                        u == 0x00002c
                    )) goto L0002;
                    ctx->cur += n;
                }
                {
                    const size_t p0 = ctx->cur;
                    const size_t n0 = chunk->thunks.n;
                    int i;
                    for (i = 0;; i++) {
                        const size_t p = ctx->cur;
                        const size_t n = chunk->thunks.n;
                        {
                            int u;
                            const size_t n = pcc_get_char_as_utf32(ctx, &u);
                            if (n == 0) goto L0003;
                            if (!(
                                (u >= 0x000031 && u <= 0x000039)
                            )) goto L0003;
                            ctx->cur += n;
                        }
                        if (ctx->cur == p) break;
                        continue;
                    L0003:;
                        ctx->cur = p;
                        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                        break;
                    }
                    if (i < 1) {
                        ctx->cur = p0;
                        pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                        goto L0002;
                    }
                }
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Alternative_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Alternative", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Alternative", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Bar(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Bar", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != '['
            ) goto L0001;
            ctx->cur++;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        L0002:;
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.n;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.n;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0003;
                    if (!(
                        u == 0x00003a ||
                        u == 0x00007c ||
                        u == 0x00005d
                    )) goto L0003;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Bar_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Bar", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Bar", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ChordDuration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ChordDuration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 4);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0003;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0003;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
            }
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != '/'
            ) goto L0002;
            ctx->cur++;
            q = ctx->cur;
            chunk->capts.p[0].range.start = p;
            chunk->capts.p[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ChordDuration_0, 0, 4);
            thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0002;
                if (!(
                    (u >= 0x000031 && u <= 0x000039)
                )) goto L0002;
                ctx->cur += n;
            }
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0004;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0004;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0004:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
            }
            q = ctx->cur;
            chunk->capts.p[1].range.start = p;
            chunk->capts.p[1].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[1].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ChordDuration_1, 0, 4);
            thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
            thunk->data.leaf.capts.p[1] = &(chunk->capts.p[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.n;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0006;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0006;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0006:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                    goto L0005;
                }
            }
            q = ctx->cur;
            chunk->capts.p[2].range.start = p;
            chunk->capts.p[2].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[2].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ChordDuration_2, 0, 4);
            thunk->data.leaf.capts.p[2] = &(chunk->capts.p[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.n;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.p[ctx->cur] != '/'
                    ) goto L0008;
                    ctx->cur++;
                    if (ctx->cur == p) break;
                    continue;
                L0008:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                    goto L0007;
                }
            }
            q = ctx->cur;
            chunk->capts.p[3].range.start = p;
            chunk->capts.p[3].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[3].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ChordDuration_3, 0, 4);
            thunk->data.leaf.capts.p[3] = &(chunk->capts.p[3]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ChordDuration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ChordDuration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NoteDuration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NoteDuration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 4);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0003;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0003;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
            }
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.p[ctx->cur] != '/'
            ) goto L0002;
            ctx->cur++;
            q = ctx->cur;
            chunk->capts.p[0].range.start = p;
            chunk->capts.p[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_NoteDuration_0, 0, 4);
            thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0002;
                if (!(
                    (u >= 0x000031 && u <= 0x000039)
                )) goto L0002;
                ctx->cur += n;
            }
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0004;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0004;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0004:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
            }
            q = ctx->cur;
            chunk->capts.p[1].range.start = p;
            chunk->capts.p[1].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[1].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_NoteDuration_1, 0, 4);
            thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
            thunk->data.leaf.capts.p[1] = &(chunk->capts.p[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.n;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0006;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0006;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0006:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                    goto L0005;
                }
            }
            q = ctx->cur;
            chunk->capts.p[2].range.start = p;
            chunk->capts.p[2].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[2].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_NoteDuration_2, 0, 4);
            thunk->data.leaf.capts.p[2] = &(chunk->capts.p[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.n;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.p[ctx->cur] != '/'
                    ) goto L0008;
                    ctx->cur++;
                    if (ctx->cur == p) break;
                    continue;
                L0008:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n0);
                    goto L0007;
                }
            }
            q = ctx->cur;
            chunk->capts.p[3].range.start = p;
            chunk->capts.p[3].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[3].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_NoteDuration_3, 0, 4);
            thunk->data.leaf.capts.p[3] = &(chunk->capts.p[3]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NoteDuration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NoteDuration", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Note(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Note", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.n;
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0003;
                        if (!(
                            u == 0x00005f ||
                            u == 0x00003d ||
                            u == 0x00005e
                        )) goto L0003;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0002;
                if (!(
                    (u >= 0x000041 && u <= 0x000047) ||
                    (u >= 0x000061 && u <= 0x000067)
                )) goto L0002;
                ctx->cur += n;
            }
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.n;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0004;
                        if (!(
                            u == 0x00002c ||
                            u == 0x000027
                        )) goto L0004;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0004:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
                    break;
                }
            }
            goto L0001;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0005;
                if (!(
                    u == 0x000058 ||
                    u == 0x000078 ||
                    u == 0x00005a ||
                    u == 0x00007a
                )) goto L0005;
                ctx->cur += n;
            }
            goto L0001;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            goto L0000;
        L0001:;
        }
        q = ctx->cur;
        chunk->capts.p[0].range.start = p;
        chunk->capts.p[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Note_0, 0, 1);
        thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
        pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Note", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Note", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EOL(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EOL", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.p + ctx->cur)[0] != '\r' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.p + ctx->cur)[1] != '\n'
        ) goto L0002;
        ctx->cur += 2;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '\r'
        ) goto L0003;
        ctx->cur++;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.p[ctx->cur] != '\n'
        ) goto L0004;
        ctx->cur++;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EOL", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EOL", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LineCont(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LineCont", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.p[ctx->cur] != '\\'
    ) goto L0000;
    ctx->cur++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.n;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    u == 0x000020 ||
                    u == 0x000009
                )) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LineCont", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LineCont", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LineBreak(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LineBreak", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &(chunk->capts), 2);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.n;
        {
            const size_t p = ctx->cur;
            size_t q;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOL, &(chunk->thunks), NULL)) goto L0002;
            q = ctx->cur;
            chunk->capts.p[0].range.start = p;
            chunk->capts.p[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[0].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_LineBreak_0, 0, 2);
            thunk->data.leaf.capts.p[0] = &(chunk->capts.p[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        {
            const size_t p = ctx->cur;
            size_t q;
            {
                const size_t p = ctx->cur;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Fragment, &(chunk->thunks), NULL)) goto L0004;
                ctx->cur = p;
                goto L0003;
            L0004:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0003;
                ctx->cur += n;
            }
            q = ctx->cur;
            chunk->capts.p[1].range.start = p;
            chunk->capts.p[1].range.end = q;
            pcc_char_array__resize(ctx->auxil, &(chunk->capts.p[1].string), 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_LineBreak_1, 0, 2);
            thunk->data.leaf.capts.p[1] = &(chunk->capts.p[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &(thunk->data.leaf.capt0.string), 0);
            pcc_thunk_array__add(ctx, &(chunk->thunks), thunk);
        }
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &(chunk->thunks), n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LineBreak", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LineBreak", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EOF(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EOF", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->buffer.n - chunk->pos));
    ctx->level++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EOF", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EOF", ctx->level, chunk->pos, (ctx->buffer.p + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

pcc_context_t *pcc_create(struct abc *auxil) {
    return pcc_context__create(auxil);
}

int pcc_parse(pcc_context_t *ctx, char *ret) {
    if (pcc_refill_buffer(ctx, 1) < 1) return 0;
    if (pcc_apply_rule(ctx, pcc_evaluate_rule_TuneBook, &(ctx->thunks), ret))
        pcc_do_action(ctx, &(ctx->thunks), ret);
    else
        PCC_ERROR(ctx->auxil);
    pcc_commit_buffer(ctx);
    pcc_thunk_array__revert(ctx, &(ctx->thunks), 0);
    return 1;
}

void pcc_destroy(pcc_context_t *ctx) {
    pcc_context__destroy(ctx);
}
